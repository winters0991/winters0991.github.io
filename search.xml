<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2017%2F05%2F17%2FHTTP%2F</url>
    <content type="text"><![CDATA[1. OSI 七层模型指什么 OSI 模型(Open System Interconnection model)是一个由国际标准化组织提出的概念模型,试图提供一个使各种不同的计算机和网络在世界范围内实现互联的标准框架。它将计算机网络体系结构划分为七层,每层都可以提供抽象良好的接口。了解 OSI 模型有助于理解互联网络的工业标准——TCP/IP 协议。OSI 模型各层间关系和通讯时的数据流向如图所示：（在实际的开发应用中一般时在此模型的基础上进行裁剪、整合） 七层模型介绍： 物理层：物理层负责最后将信息编码成电流脉冲或其它信号用于网上传输eg：RJ45等将数据转化成0和1 数据链路层:数据链路层通过物理网络链路提供数据传输。不同的数据链路层定义了不同的网络和协议特征,其中包括物理编址、网络拓扑结构、错误校验、数据帧序列以及流控;可以简单的理解为：规定了0和1的分包形式，确定了网络数据包的形式 网络层网络层负责在源和终点之间建立连接;可以理解为，此处需要确定计算机的位置，怎么确定？IPv4，IPv6 传输层传输层向高层提供可靠的端到端的网络数据流服务。可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／IP）协议 会话层会话层建立、管理和终止表示层与实体之间的通信会话；建立一个连接（自动的手机信息、自动的网络寻址） 表示层:表示层提供多种功能用于应用层数据编码和转化,以确保以一个系统应用层发送的信息 可以被另一个系统应用层识别;可以理解为：解决不同系统之间的通信，eg：Linux下的QQ和Windows下的QQ可以通信 应用层:OSI 的应用层协议包括文件的传输、访问及管理协议(FTAM) ,以及文件虚拟终端协议(VIP)和公用管理系统信息(CMIP)等;规定数据的传输协议 常见的应用层协议： 互联网分层结构的好处: 上层的变动完全不影响下层的结构。 2. HTTP 的工作原理是什么？ HTTP(HyperText Transfer Protocol超文本传输协议)是一套计算机通过网络进行通信的规则。HTTP的工作流程可分为四步： 客户端与服务器建立连接。当我们在浏览器输入网址或者当我们点击链接时，HTTP开始工作。 建立连接后，客户机发送一个请求给服务器，如当我们在浏览器地址栏输入www.baidu.com，浏览器将我们的请求封装成HTTP报文，请求报文的格式为：统一资源标识符（URL）、协议版本号，后面是MIME信息包括请求修饰符、客户机信息和可能的内容。打开浏览器控制台Network，可看到浏览器发送的请求。 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后面是MIME信息包括服务器信息、实体信息和可能的内容。 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 3. URI 的格式是什么？常见的协议有哪些 URI(统一资源标识符)，URL(统一资源定位符)。URI是更通用的资源标识符，URL是它的一个子集。URI由两个主要的子集构成： URL：通过描述资源的位置来描述资源 URN：通过名字来识别资源，和位置无关 URI 是 Uniform Resource Identifier 的缩写 Uniform：规定统一的格式，可方便处理各种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式，加入新的协议方案(HTTP, HTTPS, FTP等)也更容易 Resource：资源的定义是“可以标识的任何东西”，除了文档文件、图像或者服务（天气预报）等能够区别于其他类型的，劝都可以称为资源，另外资源不仅可以是单一的，也可以是多数的集合体 Identifier：表示可标识的对象，也成为标识符 综上所述，URI就是某个协议方案表示的资源的定位标识符，协议方案是指访问资源所使用的协议类型名称。采用HTTP协议的时候，协议方案就是http，除此之外还有ftp、mailto、file等。1234ftp://ftp.is.co.za.rfc/rfc1808.txthttp://samaritan89.github.io/f2e/js/ajax.htmlmailto:sunluyong@gmail.comtelnet://192.0.2.16:80 URI格式: 常见的协议有http、https、ftp 常见的URL主要由三部分组成 方案，也就是我们常说的协议 服务器位置 资源路径eg: http://samaritan89.github.io/f2e/js/ajax.html 通用的URL由9部分组成：&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;hash&gt; 对于web页面来说最常用的协议就是http和https user和password现在不常见了，不会在URL明文书写用户名和密码了，都是通过登录的方式 主机可以是IPO地址过着域名 端口号用来区分主机上的进程，方便找到web服务器，http默认是80 path是资源的路径，也就是存放位置，不一定和物理路径完全对应，符合web服务器路由约定即可 params，在一些协议中需要参数来访问资源，例如ftp是二进制还是文本传输，参数是名值对，用;隔开 query：这个是get请求最常用的传递参数方式了 ?a=1&amp;b=2&amp;=3 hash也成为片段，设计为标识文档的一部分，很多MVVM框架用作了路由功能 4. HTTP 协议有几种和服务器交互的方法 GETGET是最常用的方法，通常用于请求服务器发送某个资源我们平时在浏览器输入网页地址，就是给服务器发送了一个get请求，希望得到这个网页 HEADHEAD方法和GET类似，但是在服务器的响应中没有资源的内容，只有资源的一些基本信息，主要用于 在不获取资源的情况下获取资源信息（类型、大小等） 通过状态码产看资源是否存在 通过查看首部，测试资源是否被修改了 PUT和GET从服务器获取资源相反，PUT用于向服务器写入资源。PUT的语义就是让服务器用请求的主体部分创建一个请求URL命名的文档，如果存在就替换当然处于安全原因，并不是所有的服务器都实现。 POSTPOST用于向服务器发送数据，通常用来支持HTML的表单（input、select、textarea），表单中的数据会被发送到服务器 TRACE客户端发送一个请求的时候，这个请求可能会穿过防火墙、代理、网关和一些其它应用程序，没个中间节点都可能修改HTTP请求，TRACE方法允许客户端在最终请求发往服务器的时候，看看它变成了什么样子TRACE请求会在目的服务器端发送一个“闭环”诊断，行程最后一站服务器会弹回一条TRACE响应，并在响应主题中携带它收到的原始请求报文 DELETEDELETE方法用于要求服务器删除请求的URL，和PUT一样，服务器可能会不支持 OPTIONSOPTIONS方法用于请求 web服务器告知其支持的各种功能 5. 状态码200，301，304，403,404,500，503分别代表什么意思 状态码被分为五大类： 100-199 用于指定客户端应相应的某些动作。 200-299 用于表示请求成功。 300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 400-499 用于指出客户端的错误。 500-599 用于支持服务器错误。 200: “OK” 一切正常，对GET和POST请求的应答文档跟在后面。 301: “Moved Permanently” 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 304: “Not Modified” 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 403: “Forbidden” 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。 404: “Not Found” 无法找到指定位置的资源。这也是一个常用的应答。 500: “Not Implemented” 服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。 503: “Service Unavailable” 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个 Retry-After头。 6. 报文由哪几部分组成？ HTTP报文是简单的格式化数据块，每个报文都包含一条来自客户端的请求或者一条来自服务器的响应，由3个部分组成： 对报文进行描述的起始行 —— start line 包含属性的首部块 —— header 可选的包含数据的主体部分 —— body 12345HTTP/1.0 200 OKcontent-type: text/plaincontent-length: 19Hi, I&apos;m a message 起始行和首部就是由行分隔的ASCII文本，主题是一个可选的数据块，可能是文本、二进制或者空 请求报文：向web服务器请求一个动作 1234&lt;method&gt;&lt;request-URL&gt;&lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; 响应报文：讲请求结果返回给客户端 1234&lt;version&gt;&lt;status&gt;&lt;reason-phrase&gt;&lt;headers&gt;&lt;entity-body&gt; 7. 请求头的格式和作用是什么？给个范例截图说明 8. 首部的格式和作用是什么？给个范例截图说明 9. 主体的作用是什么？给个范例 服务器返回给客户端的文本信息 10. 简述浏览器缓存是如何控制的 浏览器的缓存机制，其实就是HTTP协议定义的缓存机制和HTML的meta标签缓存机制。 如果浏览器请求时，没有缓存，则向服务器请求内容，通过缓存机制判断是否需要缓存。 如果浏览器请求时，本地有缓存，那么首先判断缓存是否存在有效期，这里通过HTTP的Cahe-control和Expires指明的有效期，Cache-control的优先级更高，设置更精细。如果没有过期则读取本地缓存，如果过期了则查询其他定义 Last-Modified:这个响应资源的最后修改时间，web服务器在响应请求时，告诉浏览器资源的最后修改时间。 If-Modifled-Since:当资源过期时发现资源具有Last-Modified声明，则再次向web服务器请求时带上上头If-Modifled-Since，表示请求时间。web服务器收到请求后发现有头if-Modified-S ince则与被请求资源的最后修改时间进行比对，若最后修改时间较新则响应HTTP200，若无修改则响应HTTP304。Etag/if-None-Match也要配合Control使用 Etag:web服务器响应请求时，高速浏览器当前资源在服务器的唯一标识。 if-None-Match：当资源过期时，发现资源具有Etag声明，则再次向web服务器请求时带上头if-None-Match（Etag的值）。web服务器收到后进行比较，再决定返回200或者304。 11. 下图各个参数是什么意思]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[媒体查询&flex布局&栅格系统]]></title>
    <url>%2F2017%2F05%2F16%2F%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2-flex%E5%B8%83%E5%B1%80-%E6%A0%85%E6%A0%BC%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[1. 用媒体查询实现如下要求12341. 在页面宽度&gt; 1200px 时页面背景为红色 2. 在页面1200px&gt;=宽度&gt; 900px 时页面背景为绿色3. 在页面900px&gt;=宽度&gt; 600px 时页面背景为黄色4. 宽度&lt;=600px 背景为灰色 预览 2. 实现一个简单的栅格系统(可选题目)预览]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML5&CSS3]]></title>
    <url>%2F2017%2F05%2F16%2FHTML5-CSS3%2F</url>
    <content type="text"><![CDATA[1. HTML5是什么？有哪些新特性？有哪些新增标签？如何让低版本的 IE 支持 HTML5新标签 HTML5是超文本标记语言的第五次重大修改，2014年10月29日标准规范制定完成。HTML5的设计目的是为了在移动设备上支持多媒体。新的语法特征被引进以支持这一点，如video、audio和canvas标记。HTML5还引进了新的功能，可以真正改变用户与文档的交互方式。 新特性： 语义特性 本地存储特性 设备兼容特性 连接特性 网页多媒体特性 性能与集成特性 CSS3特性 新增标签： canvas：标签定义图形，比如图表和其他图像。该标签基于 JavaScript 的绘图 API audio：定义音频内容 video：定义视频（video 或者 movie） article：定义页面正文内容 aside：定义页面内容之外的内容 dialog：定义对话框，比如提示框 header：定义了文档的头部区域 footer：定义 section 或 document 的页脚 nav：导航 section：定义文档中的节（section、区段）等 如何让低版本的 IE 支持 HTML5新标签 方式一：Coding JavaScript 1234567891011121314&lt;!--[if lt IE9]&gt; &lt;script&gt; (function() &#123; if (! /*@cc_on!@*/ 0) return; var e = &quot;abbr, article, aside, audio, canvas, datalist, details, dialog, eventsource, figure, footer, header, hgroup, mark, menu, meter, nav, output, progress, section, time, video&quot;.split(&apos;, &apos;); var i= e.length; while (i--)&#123; document.createElement(e[i]) &#125; &#125;)() &lt;/script&gt;&lt;![endif]--&gt; 方法二：使用Google的html5shiv包（推荐） 123&lt;!--[if lt IE9]&gt; &lt;script src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 但是不管使用以上哪种方法，都要初始化新标签的CSS。因为HTML5在默认情况下表现为内联元素，对这些元素进行布局需要利用CSS手动把它们转为块状元素方便布局。 12/*html5*/article,aside,dialog,footer,header,section,footer,nav,figure,menu&#123;display:block&#125; 方法三：如果ie6/7/8 禁用脚本的用户，那么就变成了无样式的”白板”网页，该怎么解决呢？可以参照facebook的做法，即引导用户进入带有noscript标识的 “/?_fb_noscript=1”页面，用 html4 标签替换 html5 标签，这要比为了保持兼容性而写大量 hack 的做法更轻便一些。1234567&lt;!--[if lte IE 8]&gt; &lt;noscript&gt; &lt;style&gt;.html5-wrappers&#123;display:none!important;&#125;&lt;/style&gt; &lt;div class=&quot;ie-noscript-warning&quot;&gt;您的浏览器禁用了脚本，请&lt;a href=&quot;&quot;&gt;查看这里&lt;/a&gt;来启用脚本!或者&lt;a href=&quot;/?noscript=1&quot;&gt;继续访问&lt;/a&gt;. &lt;/div&gt;&lt;/noscript&gt;&lt;![endif]--&gt; 这样可以引导用户开启脚本,或者直接跳转到HTML4标签设计的界面。 2. input 有哪些新增类型？ &lt;input type=&quot;date&quot; name=&quot;bday&quot;&gt;出现一个日期选择器选择一个日期 &lt;input type=&quot;datetime&quot; name=&quot;bdaytime&quot;&gt;datetime 类型允许你选择一个日期（UTC 时间） &lt;input type=&quot;datetime-local&quot; name=&quot;bdaytime&quot;&gt;datetime-local 类型允许你选择一个日期和时间 (无时区) &lt;input type=&quot;time&quot; name=&quot;usr_time&quot;&gt;定义可输入时间控制器（无时区） &lt;input type=&quot;month&quot; name=&quot;bdaymonth&quot;&gt;month 类型允许你选择一个月份 &lt;input type=&quot;week&quot; name=&quot;week_year&quot;&gt;week 类型允许你选择周和年。 &lt;input type=&quot;color&quot; name=&quot;favcolor&quot;&gt;可以调出浏览器的调色板选择喜欢的颜色 &lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;提交的时候会自动验证email输入正不正确，相当于自动帮我们做了个正则 &lt;input type=&quot;number&quot; name=&quot;quantity&quot; min=&quot;1&quot; max=&quot;5&quot;&gt;提供一个列表选择数字，可以设定对所接受的数字的限定 &lt;input type=&quot;range&quot; name=&quot;points&quot; min=&quot;1&quot; max=&quot;10&quot;&gt;range 类型用于应该包含一定范围内数字值的输入域。range 类型显示为滑动条。 &lt;input type=&quot;search&quot; name=&quot;googlesearch&quot;&gt;search 类型用于搜索域，比如站点搜索或 Google 搜索 &lt;input type=&quot;tel&quot; name=&quot;usrtel&quot;&gt;定义输入电话号码字段 &lt;input type=&quot;url&quot; name=&quot;homepage&quot;&gt;url 类型用于应该包含 URL 地址的输入域。在提交表单时，会自动验证 url 域的值。 3. 浏览器本地存储中 cookie 和 localStorage 有什么区别？ localStorage 如何存储删除数据。 Cookie 是服务器保存在浏览器的一小段文本信息，每个 Cookie 的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。 Cookie 保存以下几方面的信息： Cookie的名字 Cookie的值 到期时间 所属域名（默认是当前域名） 生效的路径（默认是当前网址） 浏览器对Cookie数量的限制，规定不一样。目前，Firefox是每个域名最多设置50个Cookie，而Safari和Chrome没有域名数量的限制。所有Cookie的累加长度限制为4KB。超过这个长度的Cookie，将被忽略，不会被设置。 localStorage是Web Storage的一种，让网页在浏览器端保存数据，存储容量比cookie更大。localStorage长期保存数据，下一次访问该网站的时候，可以读取到之前保存的数据不同浏览器对每个域名的存储上限不同：Chrome是2.5MB，Firefox和Opera是5MB，IE是10MB。其中，Firefox的存储空间由一级域名决定，而其他浏览器没有这个限制。也就是说，在Firefox中，a.example.com和b.example.com共享5MB的存储空间。同源策略：只有同域的网页才能读取 特性 Cookie localStorage 数据的生命周期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 存放数据大小 4K左右 一般为5MB 与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 123localStorage.setItem(&apos;name&apos;, &apos;winters&apos;);//存储一个叫name的键，值为winterslocalStorage.getItem(&quot;name&quot;); //获取存储的数据localStorage.removeItem(&quot;name&quot;);//删除存储的数据 4. CSS3效果简单事例12345671. 圆角， 圆形2. div 阴影3. 2D 转换：放大、缩小、偏移、旋转4. 3D 转换：移动、旋转5. 背景色渐变6. 过渡效果7. 动画 预览 5. 全屏图加过渡色预览 6. loading 动画效果预览预览]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端设计模式]]></title>
    <url>%2F2017%2F05%2F16%2F%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 写出 构造函数模式、混合模式、模块模式、工厂模式、单例模式、发布订阅模式的范例。 构造函数模式 12345678910//构造函数模式function People(name, age)&#123; this.name = name this.age = age&#125;People.prototype.sayName = function()&#123; return this.name&#125;var person = new People(&apos;winters&apos;, 20)person.sayName()//winters 混合模式 123456789101112131415161718192021//混合模式-继承function People(name, age)&#123; this.name = name this.age = age&#125;People.prototype.sayName = function()&#123; console.log(this.name)&#125;function Man(name, age, score)&#123; People.call(this, name, age) this.score = score&#125;Man.prototype = Object.create(People.prototype)Man.prototype.sayScore = function()&#123; console.log(this.score)&#125;var man = new Man(&apos;winters&apos;, 20, 100)man.sayName()man.sayScore() 模块模式 12345678910111213//模块模式var People = (function()&#123; var name = &apos;winters&apos; function sayName()&#123; console.log(name) &#125; return &#123; name: name, sayName: sayName &#125;&#125;)()People.namePeople.sayName() 工厂模式 123456789101112//工厂模式function createPeople(opts)&#123; var people = &#123; name: opts.name || &apos;winters&apos;, sayName: function()&#123; console.log(this.name) &#125; &#125; return people&#125;var p1 = createPeople(&#123;name: &apos;hunger&apos;&#125;)var p2 = createPeople(&#123;name: &apos;jirengu&apos;&#125;) 单例模式 123456789101112131415161718192021222324252627//单例模式//构造函数的实例只有一个，可以节约内存//一般是通过闭包存储内部实例，通过接口访问内部实例var People = (function()&#123; var instance function init()&#123; //定义私有方法和属性 var name = &apos;winters&apos; return &#123; //定义公有方法和属性 getName: function()&#123; return name &#125; &#125; &#125; return &#123; createPeople: function()&#123; if(!instance)&#123; instance = init() &#125; return instance &#125; &#125;&#125;)()var person = People.createPeople()var person2 = People.createPeople()person === person2//true 发布订阅模式(可使代码解耦) 12345678910111213141516171819202122232425262728//发布订阅模式var EventCenter = (function()&#123; var events = &#123;&#125; function on(evt, handler)&#123; events[evt] = events[evt] || [] //初始为空，得到空数组，即 events[&apos;my_events&apos;] = [] events[evt].push(&#123; handler: handler//加入handler方法 &#125;) &#125; function fire(evt, args)&#123; if(!events[evt])&#123; return &#125; for(var i=0; i &lt; events[evt].length; i++)&#123; events[evt][i].handler(args) &#125; &#125; return&#123; on: on, fire: fire &#125;&#125;)()EventCenter.on(&apos;my_event&apos;, function(data)&#123; console.log(&apos;my_event received...&apos;)&#125;)EventCenter.fire(&apos;my_event&apos;) 2. 使用发布订阅模式写一个事件管理器，可以实现如下方式调用12345Event.on(&apos;change&apos;, function(val)&#123; console.log(&apos;change... now val is &apos; + val); &#125;);Event.fire(&apos;change&apos;, &apos;饥人谷&apos;);Event.off(&apos;change&apos;); 1234567891011121314151617181920212223242526272829303132//发布订阅模式-事件管理器var Event = (function()&#123; var events = &#123;&#125; function on(evt, handler)&#123; events[evt] = events[evt] || [] events[evt].push(&#123; handler: handler &#125;) &#125; function fire(evt, args)&#123; if(!events[evt])&#123; return &#125; for(var i=0; i &lt; events[evt].length; i++)&#123; events[evt][i].handler(args) &#125; &#125; function off(evt)&#123; delete events[evt] &#125; return&#123; on: on, fire: fire, off: off &#125; &#125;)() Event.on(&apos;change&apos;, function(val)&#123; console.log(&apos;change... now val is &apos; + val)&#125;)Event.fire(&apos;change&apos;, &apos;饥人谷&apos;)Event.off(&apos;change&apos;)]]></content>
      <categories>
        <category>JS工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[npm&npmscript&gulp&webpack]]></title>
    <url>%2F2017%2F05%2F16%2Fnpm-npmscript-gulp-webpack%2F</url>
    <content type="text"><![CDATA[1. 如何全局安装一个 node 应用? npm install -g xxx 2. package.json 有什么作用？ 执行npm init生成package.json文件，该文件定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。 该文件中的配置信息包括name、version、description、author、private、scripts、dependencies、decDependencies等。其中scripts定义模块包的使用方式，dependencies和devDependencies是模块包的依赖管理。12345678910111213141516171819202122232425262728293031323334353637//不提交为作业，供自己学习 &#123; &quot;name&quot;: &quot;my_package&quot;, //项目名称，全部小写，不能有空格，一个单词，允许-和_. 如果是要发布自己的node插件，一般用github上面项目名称。 &quot;version&quot;: &quot;1.0.0&quot;, //项目版本号，最好遵守 GNU 版本号管理。 &quot;main&quot;: &quot;index.js&quot;, //目录中启动文件名称。或者称之为入口文件，一般都是 index.js &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; //一般默认一个test的空文件夹、用作写测试代码。 &#125;, &quot;keywords&quot;: [], //项目的关键词。 一般用不到，发布npm才用得到。 &quot;author&quot;: &quot;ag_dubs&quot;, //作者名称 &quot;license&quot;: &quot;ISC&quot;, //协议 &quot;repository&quot;: &#123; // 用来存放到 版本管理远程服务。 发布npm才有用 &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;https://github.com/ashleygwilliams/my_package.git&quot; &#125;, &quot;devDependencies&quot; : &#123;//开发或者测试时，依赖的包。 &quot;my_test_framework&quot;: &quot;^3.1.0&quot; &#125;, &quot;dependencies&quot;: &#123; // 正式使用时，依赖的包 &quot;my_dep&quot;: &quot;^1.0.0&quot; &#125;, &quot;bugs&quot;: &#123; //同repository &quot;url&quot;: &quot;https://github.com/ashleygwilliams/my_package/issues&quot; &#125;, &quot;homepage&quot;: &quot;https://github.com/ashleygwilliams/my_package&quot; //项目主页、 发布才有用 &#125; 3. npm install –save app 与 npm install –save-dev app有什么区别? –save 会把依赖包名称添加到 package.json 中 dependencies 信息下，–save-dev 则添加到 package.json 中 devDependencies 信息下。 devDependencies 下列出的模块，是项目开发环境必需的依赖；dependencies 下的模块，则是项目发布后还需要依赖的模块。 4. nodule_modules的查找路径是怎样的? 查找路径是先从当前的node_modules 文件夹中查找,如果找到了就停止,否则就继续查找上层目录的node_modules文件夹,直至找到或者查到根路径为止。 5. npm3与 npm2相比有什么改进？yarn和 npm 相比有什么优势? npm2 问题：npm2 安装依赖的时候比较简单直接，直接按照包依赖的树形结构下载填充本地目录结构。太深的目录树结构会严重影响效率，甚至在 Windows 下可能会超出系统路径限制的长度。 npm3改进：npm install 时会按照 package.json 里依赖的顺序依次解析，遇到新的包就把它放在第一级目录，后面如果遇到一级目录已经存在的包，会先判断版本，如果版本一样则忽略，否则会按照 npm2 的方式依次挂在依赖包目录下在包版本差异化不太严重的情况下，这种构建方式会几乎把所有包放在一级目录下，很大程度上提升了效率以及节省了部分磁盘空间。在动态安装更新包的时候，npm3还可以进一步调整目录结构。 yarn和 npm 相比有什么优势? yarn是facebook为自己的sandbox形式的开发环境创造的包管理器，既然是sandbox，摒弃外部环境时，对于离线形式的包安装的支持就很重要，这也是它的最大特点：对所有已经安装过的包进行cache缓存，下次安装这些包时直接从缓存里拉取，对比与npm对网络环境的依赖，yarn解决了这个痛点。 相对于npm的队列式安装（当一个包安装完毕后才会执行下一个），yarn支持同步进行任务，速度更快。 yarn.lock: 这是一个版本锁，它记录了所有包的版本信息，也就是说，它保证了在任何一台设备上，对于包的拉取安装都是严格遵循这个版本信息。 clean：yarn支持清理命令，可以清理node-modules目录下的包文件，比如一些捆绑进入的广告以及不必要的文件。 网络恢复： 一个单独的请求并不会导致整个安装失败，这些请求可以重试直到请求恢复正常。 6. webpack是什么？和其他同类型工具比有什么优势？ Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。 市面上已经存在的模块管理和打包工具并不适合大型的项目，尤其单页面 Web 应用程序。最紧迫的原因是如何在一个大规模的代码库中，维护各种模块资源的分割和存放，维护它们之间的依赖关系，并且无缝的将它们整合到一起生成适合浏览器端请求加载的静态资源。 这些已有的模块化工具并不能很好的完成如下的目标： 将依赖树拆分成按需加载的块 初始化加载的耗时尽量少 各种静态资源都可以视作模块 将第三方库整合成模块的能力 可以自定义打包逻辑的能力 适合大项目，无论是单页还是多页的 Web 应用 webpack 优势： 代码拆分：Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。 Loader：Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。 智能解析：Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(&quot;./templates/&quot; + name + &quot;.jade&quot;)。 插件系统：Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。 快速运行：Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。 7. npm script是什么？如何使用？ npm 允许在package.json文件里面，使用scripts字段定义脚本命令。 123456&#123; // ... &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;node build.js&quot; &#125;&#125; 上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。命令行下使用npm run命令，就可以执行这段脚本。 123$ npm run build# 等同于执行$ node build.js 这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多： 项目的相关脚本，可以集中在一个地方。 不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。 可以利用 npm 提供的很多辅助功能。 常用的自定义命令行：123456789101112131415161718192021222324&#123; &quot;scripts&quot;: &#123; &quot;css:scss&quot;: &quot;app=node-sass npm run check; node-sass --output-style compressed -o dist/css src/scss&quot;, &quot;css:autoprefixer&quot;: &quot;app=postcss-cli npm run check; app=autoprefixer npm run check; postcss -u autoprefixer -r dist/css/*&quot;, &quot;css:compress&quot;: &quot;app=csso npm run check; csso in.css --output out.css&quot;, &quot;css:less&quot;: &quot;app=less npm run check; lessc --clean-css styles.less styles.min.css&quot;, &quot;js:webpack&quot;: &quot;app=webpack npm run check; webpack&quot;, &quot;js:webpack:uncompress&quot;: &quot;app=webpack npm run check; uglify=0 webpack&quot;, &quot;js:lint&quot;: &quot;app=eslint npm run check; &amp;&amp; eslint src/js&quot;, &quot;js:uglify&quot;: &quot;app=uglifyjs npm run check; mkdir -p dist/js &amp;&amp; uglifyjs src/js/*.js -m -o dist/js/app.js&quot;, &quot;image:imagemin&quot;: &quot;app=imagemin-cli npm run check; imagemin src/images dist/images -p&quot;, &quot;server&quot;: &quot;app=browser-sync npm run check; browser-sync start --server --files &apos;dist/css/*.css, dist/js/*.js&apos;&quot;, &quot;watch&quot;: &quot;app=onchange npm run check; onchange &apos;src/js/*.js&apos; -- npm run build:js&quot;, &quot;watch:webpack&quot;: &quot;onchange &apos;public/src/js/**/!(bundle.js)&apos; -- npm run webpack:js&quot;, &quot;watch:all&quot;: &quot;app=parallelshell npm run check; parallelshell &apos;npm run css:autoprefixer&apos; &apos;npm run js:init&apos; &quot;, &quot;check&quot;: &quot;[ -z \&quot;$(app=$app node -p &apos;try&#123;url=process.env.app+\&quot;/package.json\&quot;; require(url).version&#125;catch(e)&#123;exports=\&quot;\&quot;&#125;&apos;)\&quot; ] &amp;&amp; npm i -D $app || echo \&quot;already installed $app\&quot;; &quot; &#125;&#125; 8. gulp是什么？使用 gulp 实现图片压缩、CSS 压缩合并、JS 压缩合并 它是一款nodejs应用；它是打造前端工作流的利器，打包、压缩、合并、git、远程操作…；简单易用；无快不破；高质量的插件 使用 gulp 实现图片压缩、CSS 压缩合并、JS 压缩合并：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var gulp = require(&apos;gulp&apos;); //引入组件var minifycss = require(&apos;gulp-minify-css&apos;), //css压缩 uglify = require(&apos;gulp-uglify&apos;), //js压缩 concat = require(&apos;gulp-concat&apos;), //合并文件 rename = require(&apos;gulp-rename&apos;), //重命名 clean = require(&apos;gulp-clean&apos;), //清空文件夹 minhtml = require(&apos;gulp-htmlmin&apos;), //html压缩 jshint = require(&apos;gulp-jshint&apos;), //js代码规范性检查 imagemin = require(&apos;gulp-imagemin&apos;); //图片压缩gulp.task(&apos;html&apos;, function()&#123; return gulp.src(&apos;src/*.html&apos;) .pipe(minhtml(&#123;collapseWhitespace: true&#125;)) .pipe(gulp.dest(&apos;dist&apos;))&#125;);gulp.task(&apos;css&apos;, function(argument)&#123; gulp.src(&apos;src/*.css&apos;) .pipe(concat(&apos;merge.min.css&apos;)) .pipe(rename(&#123; suffix: &apos;.min&apos; &#125;)) .pipe(minfycss()) .pipe(gulp.dest(&apos;dist/css/&apos;))&#125;);gulp.task(&apos;js&apos;, function(argument)&#123; gulp.src(&apos;src/js/*.js&apos;) .pipe(jshint()) .pipe(jshint.reporter(&apos;default&apos;)) .pipe(concat(&apos;merge.js&apos;)) .pipe(rename(&#123; suffix: &apos;.min&apos; &#125;)) .pipe(uglify()) .pipe(gulp.dest(&apos;dist/js/&apos;))&#125;);gulp.task(&apos;img&apos;, function(argument)&#123; gulp.src(&apos;src/imgs/*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;dist/imgs&apos;))&#125;);gulp.task(&apos;clear&apos;, function()&#123; gulp.src(&apos;dist/*&apos;, &#123;read: false&#125;) .pipe(clean())&#125;);gulp.task(&apos;build&apos;, [&apos;html&apos;, &apos;css&apos;, &apos;js&apos;, &apos;img &apos;]); //执行gulp build;]]></content>
      <categories>
        <category>JS工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AMD&CMD&RequireJS]]></title>
    <url>%2F2017%2F05%2F16%2FAMD-CMD-RequireJS%2F</url>
    <content type="text"><![CDATA[1. 为什么要使用模块化？ 解决命名冲突 实现依赖管理 提高代码可读性 代码解耦，提高复用性 2. CMD、AMD、CommonJS 规范分别指什么？有哪些应用 CMD：即”Common Module Definition”，是 SeaJS 推广过程中产生的。在 CMD 规范中，一个模块就是一个文件。和AMD不同的是，它并不是异步加载，而是松散加载，只有当需要加载模块的时候，再用require方法引用模块。语法：define(factory) 12345678910111213141516171819202122// CMD// math.js define(function(requires, exports, module) &#123; exports.add = function(x, y) &#123; return x + y &#125;&#125;)// inc.jsdefine(function(requires, exports, module) &#123; var add = require(&apos;math&apos;).add exports.inc = function(val) &#123; return add(val, 1) &#125;&#125;)// program.jsdefine(function(require, exports, module) &#123; var inc = require(&apos;inc&apos;).inc var a = 1 inc(a) // 2 module.id = &quot;program&quot;&#125;) AMD：即”Asynchronous Module Definition”，意思就是”异步模块定义”，它是一个在浏览器端模块化开发的规范，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。实现AMD的库有”RequireJS” 、”curl” 、”Dojo” 等。语法：define(id, dependencies, factory) 1234567891011121314151617181920212223242526272829303132333435363738394041//RequireJS://创建html文件，引入Require.js库，设置data-main属性：&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;RequireJS&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/require.js/2.1.11/require.min.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;//在html目录下新建js文件夹，创建main.js：// main.js:require([&apos;starting&apos;])console.log(&quot;starting&quot;)//starting.js:define([&apos;inc&apos;], function(inc)&#123; console.log(inc.getRes()) inc.add1() console.log(inc.getRes()) inc.add1() console.log(inc.getRes())&#125;)// inc.js:define(function() &#123; var a = 1 var inc = &#123; add1: function() &#123; return a++ &#125;, getRes: function() &#123; return a &#125; &#125; return inc&#125;)//输出： starting 1 2 3 CommonJS：是服务器端模块的规范，CommonJS规范是由NodeJS发扬光大，Node.js采用了这个规范，Node.JS首先采用了js模块化的概念，commonJS有一个全局性方法require()，用于加载模块。语法： 12require(dependencies) // 加载依赖模块exports.factory = function()&#123;...&#125; // 使用”exports”对象来做为输出的唯一表示。]]></content>
      <categories>
        <category>JS工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[this&原型链&继承]]></title>
    <url>%2F2017%2F05%2F15%2Fthis-%E5%8E%9F%E5%9E%8B%E9%93%BE-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[this 相关1. apply、call 、bind有什么作用，什么区别 bind，返回一个新函数，并且使函数内部的this为传入的第一个参数 apply、call，调用一个函数，传入函数执行上下文及参数fn.call(context, param1, param2...)fn.apply(context, paramArray)第一个参数都是希望设置的this对象，不同之处在于call方法接收参数列表，而apply接收参数数组。 2. 以下代码输出什么?12345678var john = &#123; firstName: &quot;John&quot; &#125;function func() &#123; alert(this.firstName + &quot;: hi!&quot;)&#125;john.sayHi = funcjohn.sayHi()//输出：John: hi! 3. 下面代码输出什么，为什么1234func() function func() &#123; alert(this)&#125;//输出：object Window 因为函数声明前置，this的值是window 4. 下面代码输出什么123456document.addEventListener(&apos;click&apos;, function(e)&#123; console.log(this); setTimeout(function()&#123; console.log(this); &#125;, 200);&#125;, false);//输出：document window 5. 下面代码输出什么，why12345678var john = &#123; firstName: &quot;John&quot; &#125;function func() &#123; alert( this.firstName )&#125;func.call(john)//输出：john 因为call的第一个参数为this对象，所以传入对象john 6. 以下代码有什么问题，如何修改123456789101112var module= &#123; bind: function()&#123; $btn.on(&apos;click&apos;, function()&#123; console.log(this) //this指向eventTarget，即指向$btn this.showMsg(); &#125;.bind(this)) &#125;, showMsg: function()&#123; console.log(&apos;饥人谷&apos;); &#125;&#125;//问题：this指向错误，dom元素上没有方法showMsg，无法执行，已在原代码修改 原型链相关 7. 有如下代码，解释Person、 prototype、proto、p、constructor之间的关联。12345678function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function()&#123; console.log(&apos;My name is :&apos; + this.name);&#125;var p = new Person(&quot;若愚&quot;)p.sayName(); 123456p.__proto__ === Person.prototypep.__proto__.constructor === PersonPerson.prototype.__proto__ === Object.prototypePerson.prototype.constructor === PersonObject.prototype.__proto__ === nullObject.prototype.constructor === Object 8. 上例中，对对象 p 可以这样调用 p.toString()。toString是哪里来的? 画出原型图?并解释什么是原型链。 对象P是没有toString这个方法的，但是它有一个proto属性是指向Person.prototype，Person.prototype中也没有这个方法就沿着Person.prototype中的proto继续找，到了Object.prototype中就有了toString的方法，就可以调用了。这样沿着proto的”链”就是原型链。 9. 对String做扩展，实现如下方式获取字符串中频率最高的字符1234567891011121314151617181920212223String.prototype.getMostOften = function () &#123; var str = this var obj = &#123;&#125; for (var i = 0; i &lt; str.length; i++)&#123; if(obj[str[i]])&#123; obj[str[i]]++ &#125;else&#123; obj[str[i]] = 1 &#125; &#125; var sum = 0 var maxStr for(var key in obj)&#123; if(obj[key] &gt; sum)&#123; sum = obj[key] maxStr = key &#125; &#125; return maxStr&#125;var str = &apos;ahbbccdeddddfg&apos;var ch = str.getMostOften()console.log(ch) //d , 因为d 出现了5次 10. instanceof有什么作用？内部逻辑是如何实现的？ instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。 object(要检测的对象) instanceof constructor(构造函数)1234567891011function instanceof(obj, fn) &#123; var objProto = obj.__proto__ while (objProto) &#123; if (objProto === fn.prototype) &#123; return true &#125;else&#123; objProto = objProto.__proto__ &#125; &#125; return false&#125; 继承相关11. 继承有什么作用? 继承是指一个对象直接使用另一对象的属性和方法。 继承划分了类的层次性，父类代表更一般、更泛化的类，而子类则是更为具体、更为细化；继承是实现代码重用、扩展软件功能的重要手段，子类中与父类完全相同的属性和方法不必重写，只需写出新增或改写的内容，这就是说子类可以复用父类的内容，不必一切从零开始。 12. 下面两种写法有什么区别?1234567891011121314151617181920//方法1function People(name, sex)&#123; this.name = name; this.sex = sex; this.printName = function()&#123; console.log(this.name); &#125;&#125;var p1 = new People(&apos;饥人谷&apos;, 2)//方法2function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;var p1 = new Person(&apos;若愚&apos;, 27); 第一种方法中的printName方法是在构造函数Person实例对象里的，第二种方法printName方法是在函数Person的prototype对象上。当再次创建一个Person实例对象时，第一种方法会再次创建printName方法，占用新内存，而第二种方法因为printName在函数Person的原型上，所以直接在实例对象的原型链上调用就可以，达到了节省内存的效果。 13. Object.create 有什么作用？兼容性如何？ Object.create() 方法使用指定的原型对象和其属性创建了一个新的对象。Object.create(proto, [ propertiesObject ])(proto：新创建的对象的原型。) 兼容性：1234567891011121314151617181920function Person(name, age)&#123; this.name = name this.age = age&#125;Person.prototype.sayName = function()&#123; console.log(this.name)&#125;function Male(name, age, sex)&#123; Person.call(this, name, age) this.sex = sex&#125;Male.prototype = Object.create(Person.prototype)Male.prototype.constructor = Male// Male.prototype = new Person() 不兼容Object.create()时使用Male.prototype.saySex = function()&#123; console.log(this.sex)&#125;var p1 = new Male(&apos;jirengu&apos;, 3, &apos;male&apos;)p1.sayName() //jirengup1.saySex() //male 14. hasOwnProperty有什么作用？ 如何使用？ hasOwnPerperty是Object.prototype的一个方法，会返回一个布尔值，可以判断一个对象是否包含自定义属性而不是原型链上的属性，hasOwnProperty是JavaScript中唯一一个处理属性但是不查找原型链的函数。obj.hasOwnProperty(prop) //prop(要检测的属性) 以上题中代码为例：123p1.hasOwnProperty(&apos;name&apos;) // truep1.hasOwnProperty(&apos;sayName&apos;) // falseMale.prototype.hasOwnProperty(&apos;saySex&apos;) // true 15. 如下代码中call的作用是什么?12345678function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;function Male(name, sex, age)&#123; Person.call(this, name, sex); //这里的 call 有什么作用 this.age = age;&#125; 对象属性的获取是通过构造函数的执行，在一个类中执行另外一个类的构造函数，就可以把属性赋值到自己内部，但是需要把环境改到自己的作用域内，所以用到了call call的作用是在函数Male中执行构造函数Person，使Male函数能够执行Person上的初始化代码，实现构造函数继承，这样实例对象上就会有name和sex属性。 16. 补全代码，实现继承12345678910111213141516171819202122function Person(name, sex)&#123; this.name = name this.sex = sex&#125;Person.prototype.getName = function()&#123; console.log(this.name)&#125;; function Male(name, sex, age)&#123; Person.call(this, name, sex) this.age = age&#125;Male.prototype = Object.create(Person.prototype)Male.prototype.constructor = MaleMale.prototype.getAge = function()&#123; console.log(this.age)&#125;;var ruoyu = new Male(&apos;若愚&apos;, &apos;男&apos;, 27)ruoyu.getName() //若愚]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对象&原型]]></title>
    <url>%2F2017%2F05%2F15%2F%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1. OOP 指什么？有哪些特性 OOP：面向对象程序设计(Object-oriented programming)，面向对象中最重要的是类和对象。类（Class）：定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。对象是类的实例。 特征： 继承性：继承性是指，在某种情况下，一个类会有“子类”。子类比父类要更加具体化。子类会继承父类的属性和行为，并且也可包含它们自己的。 封装性：封装是通过限制只有特定类的对象可以访问这一特定类的成员，而它们通常利用接口实现消息的传入传出。 多态性：多态是指由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应。 2. 如何通过构造函数的方式创建一个拥有属性和方法的对象?1234567891011121314151617//首先定义构造函数，包括公有属性function Fn(attr)&#123; this.attr = attr&#125;//在构造函数的原型对象上定义公有的方法Fn.prototype.doSth = function ()&#123; //code&#125; //使用new方法创建实例var foo = new Fn()//new创建实例相当于以下3步var foo = &#123;&#125;foo.__proto__ = Fn.prototypeFn.call(foo); 3. prototype 是什么？有什么特性 函数的 prototype 属性是在函数作为构造器使用的时候，作为其构造对象的原型。 任何函数使用new表达式就是构造函数，每个函数都自动添加一个名称为prototype属性，这是一个对象 每个对象都有一个内部属性 proto指向其类型的prototype属性，类的实例也是对象，其proto属性指向“类”的prototype 4. 画出如下代码的原型图 12345678910111213function People (name)&#123; this.name = name; this.sayName = function()&#123; console.log(&apos;my name is:&apos; + this.name); &#125;&#125;People.prototype.walk = function()&#123; console.log(this.name + &apos; is walking&apos;); &#125;var p1 = new People(&apos;饥人谷&apos;);var p2 = new People(&apos;前端&apos;); 5. 创建一个Car对象，拥有属性name、color、status；拥有方法run，stop，getStatus1234567891011121314151617function Car(name, color, status)&#123; this.name = name this.color = color this.status = status&#125;Car.prototype = &#123; run: function()&#123; console.log(&apos;run&apos;) &#125;, stop: function()&#123; console.log(&apos;stop&apos;) &#125;, getStatus: function()&#123; console.log(this.status) &#125;&#125;var car = new Car(&apos;Lexus&apos;, &apos;white&apos;, &apos;run&apos;) 6. 创建一个 GoTop 对象，当 new 一个 GoTop 对象则会在页面上创建一个回到顶部的元素，点击页面滚动到顶部。拥有以下属性和方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*1. `ct`属性，GoTop 对应的 DOM 元素的容器2. `target`属性， GoTop 对应的 DOM 元素3. `bindEvent` 方法， 用于绑定事件4. `createNode` 方法， 用于在容器内创建节点*/&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;回到顶部&lt;/title&gt; &lt;style&gt; .container &#123; height: 1800px; &#125; .goTop &#123; position: fixed; right: 100px; bottom: 50px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt;&lt;/div&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.1.0.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function GoTop(ct)&#123; this.ct = ct this.target = $(&apos;&lt;button class=&quot;goTop&quot;&gt;回到顶部&lt;/button&gt;&apos;) this.bindEvent() this.createNode() &#125; GoTop.prototype = &#123; bindEvent: function()&#123; var $target = this.target $(window).on(&apos;scroll&apos;, function()&#123; $target.show() if($(window).scrollTop() &lt; 200)&#123; $target.hide() &#125; &#125;) $target.on(&apos;click&apos;, function()&#123; $(window).scrollTop(0) &#125;) &#125;, createNode: function()&#123; this.ct.append(this.target) this.target.hide() &#125; &#125; var btn = new GoTop($(&apos;.container&apos;)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[懒加载&轮播]]></title>
    <url>%2F2017%2F05%2F15%2F%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[1. 如何判断一个元素是否出现在窗口可视范围（浏览器的上边缘和下边缘之间，肉眼可视）。写一个函数 isVisible实现1234567891011function isVisible($node)&#123; var windowHeight = $(window).height(), scrollTop = $(window).scrollTop(), offsetTop = $node.offset().top, nodeHeight = $node.outerHeight(true) if(windowHeight + scrollTop &gt; offsetTop &amp;&amp; scrollTop &lt; offsetTop + nodeHeight)&#123; return true &#125;else&#123; return false &#125; &#125; 2. 当窗口滚动时，判断一个元素是不是出现在窗口可视范围。每次出现都在控制台打印 true 。用代码实现 12345678910111213141516171819$(window).on(&apos;scroll&apos;, function()&#123; if(isVisible($node))&#123; console.log(true) &#125;else&#123; console.log(false) &#125;&#125;) function isVisible($node)&#123; var windowHeight = $(window).height(), scrollTop = $(window).scrollTop(), offsetTop = $node.offset().top, nodeHeight = $node.outerHeight(true) if(windowHeight + scrollTop &gt; offsetTop &amp;&amp; scrollTop &lt; offsetTop + nodeHeight)&#123; return true &#125;else&#123; return false &#125; &#125; 3. 当窗口滚动时，判断一个元素是不是出现在窗口可视范围。在元素第一次出现时在控制台打印 true，以后再次出现不做任何处理。用代码实现12345678910111213141516171819202122$(window).on(&apos;scroll&apos;, function()&#123; result($ele)&#125;)function result($node)&#123; if(isVisible($node) &amp;&amp; !$node.hasClass(&apos;show&apos;))&#123; console.log(true) $node.addClass(&apos;show&apos;) &#125;&#125; function isVisible($node)&#123; var windowHeight = $(window).height(), scrollTop = $(window).scrollTop(), offsetTop = $node.offset().top, nodeHeight = $node.outerHeight(true) if(windowHeight + scrollTop &gt; offsetTop &amp;&amp; scrollTop &lt; offsetTop + nodeHeight)&#123; return true &#125;else&#123; return false &#125; &#125; 4. 图片懒加载的原理是什么？ 当访问一个页面的时候，将页面上的img标签的src属性指向一个小图片（这样就只需请求一次），把真实地址存放在一个自定义属性中，只有当图片出现在浏览器的可视区域内时，才设置图片真正的路径，让图片显示出来。 5. 轮播的实现原理是怎样的？如果让你来实现，你会抽象出哪些函数(or接口)供使用？（比如 play()） 所有轮播图片水平排列，但是视野内只有一张图片的宽度，切换图片的时候实际上是类似一卷包含全部图片的胶卷在移动。效果上利用人眼的视觉差，在瞬间变换图片的时候人眼不会有感觉，所以只要在最后一张图片后面加上第一张图片并且瞬间切换至第一张，反复这样操作就会让人产生图片无限滚动的错觉。 函数：playNext() playPre() setBullet() autoPlay()]]></content>
      <categories>
        <category>jQuery入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jQuery动画&ajax]]></title>
    <url>%2F2017%2F05%2F14%2FjQuery%E5%8A%A8%E7%94%BB-ajax%2F</url>
    <content type="text"><![CDATA[1. jQuery 中， \$(document).ready()是什么意思？ 在页面加载结束后，浏览器会通过js为DOM元素添加事件。如果把js放在&lt;body&gt;之前，原生的js中使用window.onload方法，在jQuery中使用$(document).ready()。 window.onload是所有元素、图片、外部资源都加载完执行，而$(document).ready()只需要DOM元素加载完成。 2. \$node.html()和\$node.text()的区别?123456&lt;div class=&quot;node&quot;&gt; &lt;p&gt;我是段落&lt;/p&gt;&lt;/div&gt;$(&apos;.node&apos;).html() //&lt;p&gt;我是段落&lt;/p&gt;$(&apos;.node&apos;).text() //我是段落 3. \$.extend 的作用和用法? jQuery.extend([deep,] target [, object1 ] [, objectN ] ) 将两个或多个对象传递给$.extend()，对象的所有属性都添加到目标对象（target参数） 123456789var obj = &#123;&#125;var obj1 = &#123; name: &apos;winters&apos;, age: &apos;25&apos;&#125;$.extend(obj, obj1); //也可以写为：var obj = $.extend(&#123;&#125;, obj1)console.log(obj) // obj: &#123;name: &apos;winters&apos;, age: &apos;25&apos;&#125; $.extend()的第一个参数为布尔值，Boolean为true时，为深拷贝；Boolean为false时，为浅拷贝。 默认为false 浅拷贝 12345678910var obj = &#123;&#125;var obj1 = &#123; name: &apos;winters&apos;, age: 25, hobby: [1,2,3]&#125;$.extend(obj, obj1)obj.hobby[0] = &apos;others&apos;console.log(obj.hobby) // [&apos;others&apos;, 2, 3]console.log(obj1.hobby) // [&apos;others&apos;, 2, 3] 浅拷贝，同一处引用 当为true时为深拷贝 12345678910var obj = &#123;&#125;var obj1 = &#123; name: &apos;winters&apos;, age: 25, hobby: [1,2,3]&#125;$.extend(true, obj, obj1)obj.hobby[0] = &apos;others&apos;console.log(obj.hobby) // [&apos;others&apos;, 2, 3]console.log(obj1.hobby) // [1, 2, 3] 深拷贝，不同引用 4. jQuery 的链式调用是什么？ 由于jQuery的方法都会返回一个jQuery对象，所以可以使用诸如$(node).method1().method2().method2().method3....的形式，即jQuery的链式调用，可使代码更加简化，增加代码易读性。 5. jQuery 中 data 函数的作用 jQuery中的data函数用于在当前jQuery对象所匹配的所有元素上存取数据，data()函数存取的数据都是临时数据，一旦页面刷新，之前存放的数据都将不复存在。如果需要移除用removeData()方法。 用法：$(selector).data(key,value)$(selector).data(object) 6. 写出以下功能对应的 jQuery 方法： 给元素 \$node 添加 class active，给元素 \$noed 删除 class active$node.addClass(&#39;active&#39;)$noed.removeClass(&#39;active&#39;) 展示元素\$node, 隐藏元素\$node$node.show()$node.hide() 获取元素\$node 的属性: id、src、title， 修改以上属性 12345678//获取$node.attr(&apos;id&apos;)$node.attr(&apos;src&apos;)$node.attr(&apos;title&apos;)//修改$node.attr(&apos;id&apos;, &apos;newid&apos;)$node.attr(&apos;src&apos;, &apos;newsrc&apos;)$node.attr(&apos;title&apos;, &apos;newtitle&apos;) 给\$node 添加自定义属性data-src$node.attr(&#39;data-src&#39;, &#39;somesrc&#39;) 在\$ct 内部最开头添加元素\$node$ct.prepend($node) 在\$ct 内部最末尾添加元素\$node$ct.append($node) 删除\$node$node.remove() 把\$ct里内容清空$ct.empty(&#39;&#39;) 或 $ct.html(&#39;&#39;) 在\$ct 里设置 html&lt;div class=&quot;btn&quot;&gt;&lt;/div&gt;$ct.html(&#39;&lt;div class=&quot;btn&quot;&gt;&lt;/div&gt;&#39;) 获取、设置\$node 的宽度、高度(分别不包括内边距、包括内边距、包括边框、包括外边距) 12345678$node.width()$node.height()$node.innerWidth()$node.innerHeight()$node.outerWidth()$node.outerHeight()$node.outerWidth(true)$node.outerHeight(true) 获取窗口滚动条垂直滚动距离$(window).scrollTop() 获取\$node 到根节点水平、垂直偏移距离$node.offset() 修改\$node 的样式，字体颜色设置红色，字体大小设置14px 1234$node.css(&#123; &apos;color&apos;: &apos;red&apos;, &apos;font-size&apos;: &apos;14px&apos;&#125;) 遍历节点，把每个节点里面的文本内容重复一遍 123$(selector).each(function()&#123; console.log($(this).text())&#125;) 从\$ct 里查找 class 为 .item的子元素$ct.find(&#39;.item&#39;) 获取\$ct 里面的所有孩子$ct.children() 对于\$node，向上找到 class 为’.ct’的父亲，在从该父亲找到’.panel’的孩子$node.parents(&#39;.ct&#39;).find(&#39;.panel&#39;) 获取选择元素的数量$node.length 获取当前元素在兄弟中的排行$node.index() 7. 用jQuery实现以下操作 当点击\$btn 时，让 \$btn 的背景色变为红色再变为蓝色 当窗口滚动时，获取垂直滚动距离 当鼠标放置到\$div 上，把\$div 背景色改为红色，移出鼠标背景色变为白色 当鼠标激活 input 输入框时让输入框边框变为蓝色，当输入框内容改变时把输入框里的文字小写变为大写，当输入框失去焦点时去掉边框蓝色，控制台展示输入框里的文字 当选择 select 后，获取用户选择的内容预览]]></content>
      <categories>
        <category>jQuery入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器&Dom操作&样式&事件处理]]></title>
    <url>%2F2017%2F05%2F13%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8-Dom%E6%93%8D%E4%BD%9C-%E6%A0%B7%E5%BC%8F-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 说说库和框架的区别？ 库和框架都是一种有别于软件、面向程序开发者的产品形式。 库：Library(简写Lib)，框架：Framework。 库是将代码集合成的一个产品，供程序员调用。面向对象的代码组织形式而成的库也叫类库。面向过程的代码组织形式而成的库也叫函数库。在函数库中的可直接使用的函数叫库函数。开发者在使用库的时候，只需要使用库的一部分类或函数，然后继续实现自己的功能。 框架则是为解决一个(一类)问题而开发的产品，框架用户一般只需要使用框架提供的类或函数，即可实现全部功能。可以说，框架是库的升级版。开发者在使用框架的时候，必须使用这个框架的全部代码。 框架通过封装处理流程的控制逻辑，使它对开发者透明，来简化开发工作。 2. jquery 能做什么？ jQuery 是一个高效、精简并且功能丰富的 JavaScript 工具库。它提供的 API 易于使用且兼容众多浏览器，这让诸如 HTML 文档遍历和操作、事件处理、动画和 Ajax 操作更加简单。 3. jquery 对象和 DOM 原生对象有什么区别？如何转化？ DOM对象是通过原生JavaScript获得的对象，jQuery对象是通过jQuery选择器获得的对象；jQuery对象只能使用jQuery的属性和方法，DOM对象只能使用DOM的属性和方法 jQuery对象转DOM对象（可以通过类数组下标的获取方式或者get方法获取指定index的DOM对象） 12345&lt;ul id=&quot;ct&quot;&gt; &lt;li class=&apos;number&apos;&gt;one&lt;/li&gt; &lt;li class=&apos;number&apos;&gt;two&lt;/li&gt; &lt;li class=&apos;number&apos;&gt;three&lt;/li&gt; &lt;/ul&gt; 通过类数组下标的获取方式 12$(&apos;.number&apos;)[2] //&lt;li class=&apos;number&apos;&gt;three&lt;/li&gt;$(&apos;.number&apos;).eq(2)[0] //&lt;li class=&apos;number&apos;&gt;three&lt;/li&gt; 通过get方法 1$(&apos;.number&apos;).get(2) //&lt;li class=&apos;number&apos;&gt;three&lt;/li&gt; DOM对象转jQuery对象（使用$()将DOM对象包裹起来就是jQuery对象） 12var ct = document.getElementById(&apos;ct&apos;) //DOM对象var $ct = $(ct) //转化为jQuery对象$ct 4. jquery中如何绑定事件？bind、unbind、delegate、live、on、off都有什么作用？推荐使用哪种？使用on绑定事件使用事件代理的写法？ jQuery中绑定事件的方法：.bind(),.live(),.delegate(),.on() 1234$(&apos;#ct&apos;).bind(&apos;click&apos;,function()&#123;&#125;);//这是最直接的绑定方法。jQuery 扫描文档找到所有 $(&apos;#ct&apos;) 元素，然后给每一个找到的元素的 click 事件绑定处理函数。$(&apos;#ct&apos;).unbind(&apos;&apos;) //不传参数，解绑所有事件$(&apos;#ct&apos;).unbind(&apos;click&apos;) //传入参数，解绑指定事件 delegate为事件代理 1$(&apos;#ct&apos;).delegate(&apos;a&apos;, &apos;click&apos;, function());//jQuery扫描文档找到 $(&apos;#ct&apos;)，绑定处理函数到它的 click 事件，&apos;a&apos; css选择器作为函数的参数。当有事件冒泡到 $(&apos;#ct&apos;)，检查事件是不是 click，并检查target element是不是匹配css选择器，如果两者都符合，执行函数。 live 1$(&apos;a&apos;).live(&apos;click&apos;, function());//jQuery绑定处理函数到 $(document) 元素，并把 &apos;click&apos; 和 &apos;a&apos; 作为函数的参数。有事件冒泡到document节点的时候，检查这个事件是不是 click 事件，target element能不能匹配 &apos;a&apos; css选择器，如果两个条件都是true，处理函数执行。 jQuery 的 delegate 方法比 live 方法好 在1.7之前的版本中jQuery处理事件有多个方法，作用各不相同，后来统一使用on/off（解绑事件）方法$(&#39;#ct&#39;).on(events,selector,function()) 5. jquery 如何展示/隐藏元素？12$(selecctor).hide(speed,callback);$(selecctor).show(speed,callback); speed：表示速度的参数，可选（slow,fast,normal）或者毫秒数;callback：是隐藏或显示完成后所执行的函数名称。 6. jquery 动画如何使用？$(selector).animate( properties [, duration ] [, easing ] [, complete ] )//properties是一个CSS属性和值的对象,动画将根据这组对象移动。后面三个参数可选。 7. 如何设置和获取元素内部 HTML 内容？如何设置和获取元素内部文本？1234$(&apos;#ct&apos;).html() //获取元素内部HTML$(&apos;#ct&apos;).html([string]) //设置元素内部HTML$(&apos;#ct&apos;).text() //获取元素内部文本$(&apos;#ct&apos;).text(value) //设置元素内部文本 8. 如何设置和获取表单用户输入或者选择的内容？如何设置和获取元素属性？ .val([value])这是一个读写双用的方法，用来处理input的value，当方法没有参数的时候返回input的value值，当传递了一个参数的时候，方法修改input的value值为参数值12$(&apos;input&apos;).val()$(&apos;input&apos;).val(&apos;newValue&apos;) 12.attr(attributeName) //获取元素特定属性的值.attr(attributeName, value)//为元素属性赋值]]></content>
      <categories>
        <category>jQuery入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JSONP&跨域]]></title>
    <url>%2F2017%2F05%2F13%2FJSONP-%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[1. 什么是同源策略 浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。本域指:同协议：如都是http或者https同域名：如都是http://www.example.com/dir 和http://www.example.com/dir2同端口：如都是80端口 同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 如果非同源，共有三种行为受到限制：（1） Cookie、LocalStorage 和 IndexedDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。 2. 什么是跨域？跨域有几种实现形式 跨域是指在不同的域之间进行数据传输或通信 JSONP CORS 跨域资源共享(Cross-Origin Resource Sharing)，IE支持10以上 降域 postMessage 3. JSONP 的原理是什么 定义数据处理函数fun 创建script标签，src的地址执行后端接口，最后加个参数callback=fun 后端在收到请求后，解析参数，计算返还数据，输出 fun(data) 字符串。 fun(data)会放到script标签做为js执行。此时会调用fun函数，将data做为参数。 4. CORS是什么 CORS 全称是跨域资源共享（Cross-Origin Resource Sharing），是一种 ajax 跨域请求资源的方式，支持现代浏览器，IE支持10以上。 实现方式很简单，当使用 XMLHttpRequest 发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：Access-Control-Allow-Origin; 浏览器判断该响应头中是否包含 Origin 的值，如果有则浏览器会处理响应，就可以拿到响应数据，如果不包含浏览器直接驳回，这时无法拿到响应数据。所以 CORS 的表象是让你觉得它与同源的 ajax 请求没什么区别，代码完全一样。]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2017%2F05%2F13%2FAjax%2F</url>
    <content type="text"><![CDATA[1. ajax 是什么？有什么作用？ Ajax是Asynchronous JavaScript and XML的缩写，Ajax在浏览器与 Web 服务器之间使用异步数据传输（HTTP 请求）从服务器获取数据。这里的异步是指脱离当前浏览器页面的请求、加载等单独执行，这意味着可以在不重新加载整个网页的情况下，通过JavaScript发送请求、接受服务器传来的数据，然后操作DOM将新数据对网页的某部分进行更新，使用Ajax最直观的感受是向服务器获取新数据不需要刷新页面等待了。 2. 前后端开发联调需要注意哪些事情？后端接口完成前如何 mock 数据？ 1、确定接口名称，统一命名，定制规范2、传输数据类型的确定以及数据大小等限制的确定3、服务器、端口、方法、请求数据的一些限制 使用XAMPP等工具，搭建本地php服务器，编写php脚本提供临时数据 使用mock.js生成模拟数据，拦截AJAX请求，并且返回模拟的数据进行测试 使用node server-mock，解决后端模板的渲染和AJAX接口的处理来模拟数据 3. 点击按钮，使用 ajax 获取数据，如何在数据到来之前防止重复点击? 12345678910111213141516var ajaxLock = false //状态锁，处于打开状态btn.addEventListener(&apos;click&apos;, function()&#123; if(ajaxLock)&#123; return //如果状态锁上锁，即正在请求数据，那么接下来的点击无效 &#125;else&#123; xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; //do sth ajaxLock = false //数据到来后，解锁 &#125; &#125; //ajax配置 xhr.send() ajaxLock = true //发送请求后立即上锁 &#125;&#125;) 4. 封装一个 ajax 函数，能通过如下方式调用。后端在本地使用server-mock来 mock 数据1234567891011121314151617181920212223242526272829303132333435363738394041424344function ajax(opts)&#123; //设置默认情况 opts.success = opts.success || function()&#123;&#125; opts.error = opts.error || function()&#123;&#125; opts.type = opts.type || &apos;get&apos; opts.dataType = opts.dataType || &apos;json&apos; opts.data = opts.data || &#123;&#125; //拼接参数 var dataStr = &apos;&apos; for(var key in opts.data)&#123; dataStr += key + &apos;=&apos; + opts.data[key] + &apos;&amp;&apos; &#125; dataStr = dataStr.substr(0, dataStr.length - 1) //创建ajax，设置请求完成回调 var xmlhttp = new XMLHttpRequest() xmlhttp.onreadystatechange = function()&#123; if(xmlhttp.readyState === 4)&#123; if(xmlhttp.status === 200 || xmlhttp.status === 304)&#123; if(opts.dataType === &apos;text&apos;)&#123; opts.success(xmlhttp.responseText) &#125; if(opts.dataType === &apos;json&apos;)&#123; var json =JSON.parse(xmlhttp.responseText) opts.success(json) &#125; &#125;else&#123; opts.error() &#125; &#125; &#125; //判断请求方式并发送请求 if(opts.type.toLowerCase() === &apos;post&apos;)&#123; xmlhttp.open(opts.type, opts.url, true) xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;) xmlhttp.send(dataStr) &#125; if(opts.type.toLowerCase() === &apos;get&apos;)&#123; xmlhttp.open(opts.type, opts.url + &apos;?&apos; + dataStr, true) xmlhttp.send() &#125;&#125;]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[闭包&定时器&BOM]]></title>
    <url>%2F2017%2F05%2F13%2F%E9%97%AD%E5%8C%85-%E5%AE%9A%E6%97%B6%E5%99%A8-BOM%2F</url>
    <content type="text"><![CDATA[1. 下面的代码输出多少？修改代码让fnArri 输出 i。使用两种以上的方法1234567var fnArr = []; for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = function()&#123; return i; &#125;; &#125; console.log( fnArr[3]() ); // 输出：10 执行时循环结束i等于10，所以整个数组元素执行后都会是10 方法一：创建闭包，闭包内保存i 12345678910var fnArr = []; for (var i = 0; i &lt; 10; i ++) &#123; (function ()&#123; var n = i; fnArr[i] = function()&#123; return n; &#125;; &#125;)(); &#125; console.log( fnArr[3]() );// 3 方法二：立即执行函数 123456789101112var fnArr = []; for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = (function()&#123; var n = i; return function()&#123; return n; &#125;; &#125;)(); &#125; console.log( fnArr[3]() );// 3`` 2. 封装一个汽车对象，可以通过如下方式获取汽车状态12345678910111213141516171819202122232425262728293031323334353637383940414243var Car = (function()&#123; var speed = 0; function setSpeed(s)&#123; speed = s; &#125; function getSpeed()&#123; return speed; &#125; function accelerate()&#123; speed += 10; &#125; function decelerate()&#123; if(speed &gt;= 10)&#123; speed -= 10; &#125; &#125; function getStatus()&#123; if(speed &gt; 0)&#123; return &apos;running&apos;; &#125;else&#123; return &apos;stop&apos;; &#125; &#125; return &#123; setSpeed: setSpeed, getSpeed: getSpeed, accelerate: accelerate, decelerate: decelerate, getStatus: getStatus &#125;;&#125;)();Car.setSpeed(30);Car.getSpeed(); //30Car.accelerate();Car.getSpeed(); //40;Car.decelerate();Car.decelerate();Car.getSpeed(); //20Car.getStatus(); // &apos;running&apos;;Car.decelerate(); Car.decelerate();Car.getStatus(); //&apos;stop&apos;;//Car.speed; //error 3. 下面这段代码输出结果是? 为什么? 12345678910var a = 1;setTimeout(function()&#123; a = 2; console.log(a);&#125;, 0);var a ;console.log(a);a = 3;console.log(a);//输出：1 3 2 setTimeout的运行机制是，将指定的代码移出本次执行，等到下一轮Event Loop时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮Event Loop时重新判断。这意味着，setTimeout指定的代码，必须等到本次执行的所有代码都执行完，才会执行。 4. 下面这段代码输出结果是? 为什么?1234567var flag = true;setTimeout(function()&#123; flag = false;&#125;,0)while(flag)&#123;&#125;console.log(flag);//不会输出 代码中包含了一个死循环，所以永远都不会执行到setTimeout中的代码。 5. 下面这段代码输出？如何输出delayer: 0, delayer:1...（使用闭包来实现）123456for(var i=0;i&lt;5;i++)&#123; setTimeout(function()&#123; console.log(&apos;delayer:&apos; + i ); &#125;, 0); console.log(i);&#125; //输出：0 1 2 3 4 然后输出5次delayer:5 123456789for(var i=0;i&lt;5;i++)&#123; (function ()&#123; var n = i; setTimeout(function()&#123; console.log(&apos;delayer:&apos; + n ); &#125;, 0); &#125;)(); console.log(i);&#125; 6. 如何获取元素的真实宽高12345678function trueSize(ele,pseudoCla)&#123; if(window.getComputedStyle)&#123; return getComputedStyle(ele,pseudoCla); &#125;else if(element.currentStyle)&#123; return element.currentStyle; //低版本IE支持的方式 &#125;&#125; 7. URL 如何编码解码？为什么要编码？ 编码： encodeURI() encodeURIComponent() 解码： decodeURI() decodeURIComponent() encodeURIComponent比encodeURI编码的范围更大。 编码原因：有些字符有歧义、包含隐私数据、Size过大 8. 补全如下函数，判断用户的浏览器类型123456789101112function isAndroid()&#123; return /Android/.test(navigator.userAgent);&#125;funcnction isIphone()&#123; return /iphone/i.test(navigator.userAgent);&#125;function isIpad()&#123; return /ipad/i.test(navigator.userAgent);&#125;function isIOS()&#123; return /(ipad)|(iphone)/i.test(navigator.userAgent);&#125;]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2F2017%2F05%2F12%2F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1. DOM0 事件和DOM2级在事件监听使用方式上有什么区别？ DOM0：把一个方法赋值给一个元素的事件处理程序属性，这样处理，事件处理程序被认为是元素的方法，事件处理程序在元素的作用域下运行，this就是当前元素。这样的缺陷是：同一个事件只能有一个事件监听函数，再次添加会产生覆盖。 1234var btnClick = document.getElementById(&apos;btnClick&apos;);btnClick.onclick = function handler() &#123; alert(this.id);&#125;; //bthClick DOM2：这种方式可以给一个同一个元素添加多个处理事件，同时它的this也指向元素本身。 1234var btnClick = document.getElementById(&apos;btnClick&apos;);btnClick.addEventListener(&apos;click&apos;, function() &#123; alert(this.id);&#125;, false); //btnClick 2. attachEvent与addEventListener的区别？ 适用浏览器不同：attachEvent是IE的事件处理方法，addEventListener是标准浏览器的处理方式。 参数个数不相同：addEventListener有三个参数，attachEvent只有两个，attachEvent添加的事件处理程序只能发生在冒泡阶段，addEventListener第三个参数可以决定添加的事件处理程序是在捕获阶段还是冒泡阶段处理。 第一个参数意义不同：addEventListener第一个参数是事件类型（比如click，load），而attachEvent第一个参数指明的是事件处理函数名称（onclick，onload）。 事件处理程序的作用域不相同：addEventListener的作用域是元素本身，this是指的触发元素，而attachEvent事件处理程序会在全局变量内运行，this是window。 为一个事件添加多个事件处理程序时，执行顺序不同：addEventListener添加会按照添加顺序执行，而attachEvent添加多个事件处理程序时顺序无规律。 3. 解释IE事件冒泡和DOM2事件传播机制？ IE的事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的元素。 DOM2：DOM2级事件规定事件流包括三个阶段，事件捕获阶段，处于目标阶段，事件冒泡阶段，首先发生的是事件捕获，为截取事件提供机会，然后是实际目标接收事件，最后是冒泡阶段。 4. 如何阻止事件冒泡？ 如何阻止默认事件？ DOM浏览器： 阻止事件冒泡：stopPropagation() 阻止默认事件：preventDefault() IE浏览器： 阻止事件冒泡：cancelBubble 默认为false，设置为true后可以取消事件冒泡 阻止默认事件：returnValue 默认为true，设为false可以取消事件默认行为 5. 有如下代码，要求当点击每一个元素li时控制台展示该元素的文本内容。不考虑兼容。12345678910111213&lt;ul class=&quot;ct&quot;&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;饥人谷&lt;/li&gt; &lt;li&gt;前端6班&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var lis = document.querySelectorAll(&apos;.ct li&apos;);for(var i = 0; i &lt; lis.length; i++)&#123; lis[i].addEventListener(&apos;click&apos;, function()&#123; console.log(this.innerText); &#125;)&#125;&lt;/script&gt; 6. 补全代码，要求： 当点击按钮开头添加时在这里是元素前添加一个新元素，内容为用户输入的非空字符串；当点击结尾添加时在最后一个 li 元素后添加用户输入的非空字符串. 当点击每一个元素li时控制台展示该元素的文本内容。12345678910111213141516171819202122232425262728293031323334&lt;ul class=&quot;ct&quot;&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;饥人谷&lt;/li&gt; &lt;li&gt;任务班&lt;/li&gt;&lt;/ul&gt;&lt;input class=&quot;ipt-add-content&quot; placeholder=&quot;添加内容&quot;/&gt;&lt;button id=&quot;btn-add-start&quot;&gt;开头添加&lt;/button&gt;&lt;button id=&quot;btn-add-end&quot;&gt;结尾添加&lt;/button&gt;&lt;script&gt; var ipt = $(&apos;.ipt-add-content&apos;); var addStart = $(&apos;#btn-add-start&apos;); var endStart = $(&apos;#btn-add-end&apos;); var ct = $(&apos;.ct&apos;); ct.addEventListener(&apos;click&apos;, function(e)&#123; console.log(e.target.innerText); &#125;) addStart.addEventListener(&apos;click&apos;, function()&#123; var li = document.createElement(&apos;li&apos;); li.innerText = ipt.value; ct.insertBefore(li, ct.firstChild); &#125;) endStart.addEventListener(&apos;click&apos;, function()&#123; var li = document.createElement(&apos;li&apos;); li.innerText = ipt.value; ct.appendChild(li); &#125;) function $(id)&#123; return document.querySelector(id); &#125; function $$(clas)&#123; return document.querySelectorAll(clas); &#125;&lt;/script&gt; 7. 补全代码，要求：当鼠标放置在li元素上，会在img-preview里展示当前li元素的data-img对应的图片。12345678910111213141516171819202122&lt;ul class=&quot;ct&quot;&gt; &lt;li data-img=&quot;1.png&quot;&gt;鼠标放置查看图片1&lt;/li&gt; &lt;li data-img=&quot;2.png&quot;&gt;鼠标放置查看图片2&lt;/li&gt; &lt;li data-img=&quot;3.png&quot;&gt;鼠标放置查看图片3&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;img-preview&quot;&gt;&lt;/div&gt;&lt;script&gt;var preview = document.querySelector(&apos;.img-preview&apos;);var ct = document.querySelector(&apos;.ct&apos;);ct.addEventListener(&apos;mouseover&apos;, function(e)&#123; if(e.target.tagName.toLowerCase() === &apos;li&apos;)&#123; var img = document.createElement(&apos;img&apos;); img.src = e.target.getAttribute(&apos;data-img&apos;); preview.appendChild(img); &#125;&#125;)ct.addEventListener(&apos;mouseout&apos;, function(e)&#123; if(e.target.tagName.toLowerCase() === &apos;li&apos;)&#123; preview.innerHTML = &apos;&apos;; &#125;&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DOM操作]]></title>
    <url>%2F2017%2F05%2F12%2FDOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. dom对象的innerText和innerHTML有什么区别？ innerText是一个可写属性，返回元素内包含的文本内容，在多层次的时候会按照元素由浅到深的顺序拼接其内容。 innerHTML属性作用和innerText类似，但是不是返回元素的文本内容，而是返回元素的HTML结构，在写入的时候也会自动构建DOM。 2. elem.children和elem.childNodes的区别？ Element.children：子元素列表（HTMLCollection），返回一个HTMLCollection对象，包括当前元素节点的所有子元素。 Element.childNodes：子元素列表（NodeList），返回一个NodeList集合，包括当前节点的HTML元素节点，还返回Text节点和Comment节点。 3. 查询元素有几种常见的方法？ES5的元素选择方法是什么? getElementById() getElementsByClassName() getElementsByTagName() getElementsByName()ES5的元素选择方法： querySelector() querySelectorAll() 4. 如何创建一个元素？如何给元素设置属性？如何删除属性 创建元素：createElement() 给元素设置属性：setAttribute(“属性名”, “属性值”) 删除属性：romoveAttribute(“属性名”) 5. 如何给页面元素添加子元素？如何删除页面元素下的子元素? 添加元素：var newDiv = document.createELement(‘newDivName’);document.body.appendChild(newDiv); 删除元素：document.body.removeChild(newDiv); 6. element.classList有哪些方法？如何判断一个元素的 class 列表中是包含某个 class？如何添加一个class？如何删除一个class? element.classList 是一个只读属性，返回一个元素的类属性的实时 DOMTokenList集合。 add(className)：添加类 remove(className)：删除类 contains(className)：是否包含指定类名，返回布尔值 toString()：将类数组对象转为字符串 element.classList.contains(className)：判断是否包含且返回布尔值 element.classList.add(className)：添加类 element.classList.remove(className)：删除类 7. 如何选中如下代码所有的li元素？ 如何选中btn元素？12345678910&lt;div class=&quot;mod-tabs&quot;&gt; &lt;ul&gt; &lt;li&gt;list1&lt;li&gt; &lt;li&gt;list2&lt;li&gt; &lt;li&gt;list3&lt;li&gt; &lt;/ul&gt; &lt;button class=&quot;btn&quot;&gt;点我&lt;/btn&gt;&lt;/div&gt;//document.querySelectorAll(&apos;.mod-tabs &gt; ul &gt; li&apos;)document.querySelector(&apos;.btn&apos;)]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F05%2F12%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. \d，\w, \s, [a-zA-Z0-9], \b, ., *, +, ?, x{3}, ^, $ 分别是什么? \d 表示：数字字符 [0-9] \w 表示：单词字符、字母、数字、下划线 [a-zA-Z_0-9] \s 表示：空白符 [\t\n\x0B\f\r] [a-zA-Z0-9] 表示：字母（包括大小写）、数字0-9s \b 表示：单词边界 . 表示：除了回车符和换行符之外的所有字符 [^\r\n] * 表示：出现零次或多次（任意次） + 表示：出现一次或多次（至少出现一次） ? 表示：出现零次或一次（最多出现一次） x{3} 表示：x出现3次 ^ 表示：以xxx开头 $ 表示：以xxx结尾 2. 写一个函数trim(str)，去除字符串两边的空白字符123function trim(str)&#123; return str.replace(/^\s+|\s+$/g, &apos;&apos;);&#125; 3. 写一个函数isEmail(str)，判断用户输入的是不是邮箱 1234function isEmail(str)&#123; var reg = /^\w+@[\w.-]+$/; return reg.test(str);&#125; 4. 写一个函数isPhoneNum(str)，判断用户输入的是不是手机号123function isPhoneNum(str)&#123; return /^(\+86-)?1[34578]\d&#123;9&#125;$/.test(str);&#125; 5. 写一个函数isValidUsername(str)，判断用户输入的是不是合法的用户名（长度6-20个字符，只能包括字母、数字、下划线）123function isValidUsername(str)&#123; return /^\w&#123;6,20&#125;$/.test(str)&#125; 6. 写一个函数isValidPassword(str), 判断用户输入的是不是合法密码（长度6-20个字符，只包括大写字母、小写字母、数字、下划线，且至少包括两种）12345678function isValidPassword(str)&#123; if(str.length &lt; 6 || str.length &gt; 20 || /\W/.test(str))&#123; return false; &#125;else if(/(^[A-Z]+$)|(^[a-z]+$)|(^[0-9]+$)|(^_+$)/.test(str))&#123; return false; &#125; return true;&#125; 7. 写一个正则表达式，得到如下字符串里所有的颜色123var re = /#[0-9a-fA-F]&#123;6&#125;/g;var subj = &quot;color: #121212; background-color: #AA00ef; width: 12px; bad-colors: f#fddee &quot;console.log( subj.match(re) ) // [&apos;#121212&apos;, &apos;#AA00ef&apos;] 8. 下面代码输出什么? 为什么? 改写代码，让其输出[‘hunger’, ‘world’].1234var str = &apos;hello &quot;hunger&quot; , hello &quot;world&quot;&apos;;var pat = /&quot;.*&quot;/g;str.match(pat);//输出：[&quot;&quot;hunger&quot; , hello &quot;world&quot;&quot;] 为贪婪模式状态下//修改： var pat = /&quot;.*?&quot;/]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Math&数组&Date]]></title>
    <url>%2F2017%2F05%2F11%2FMath-%E6%95%B0%E7%BB%84-Date%2F</url>
    <content type="text"><![CDATA[Math1. 写一个函数，返回从min到max之间的随机整数，包括min不包括max123function randomInt(min, max) &#123; return Math.floor(Math.random() * (max - min)) + min;&#125; 非作业内容 //检测随机数出现频率1234567891011121314151617function randomInt(min,max)&#123;//得出每个随机数的次数 var MAX = 10000; var obj = &#123;&#125;; for(var i = 0; i &lt; MAX; i++)&#123; var val = Math.floor(Math.random() * (max - min)) + min; if(obj[val] === undefined)&#123; obj[val] = 1; &#125;else&#123; obj[val]++; &#125; &#125;//得出每个随机数的频率 for(var key in obj)&#123; obj[key] = obj[key]/MAX &#125;console.log(obj); 2. 写一个函数，返回从min都max之间的随机整数，包括min包括max123function randomInt(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min;&#125; 3. 写一个函数，生成一个长度为 n 的随机字符串，字符串字符的取值范围包括0到9，a到 z，A到Z。1234567891011function getRandStr(len)&#123; var dict = &apos;0123456789abcdefghijkmnlopqrstuvwxyzABCDEFGHIJKMNLOPQRSTUVWXYZ&apos;; var ch, str = &apos;&apos;; for(var i = 0; i &lt; len; i++)&#123; var idx = Math.floor(Math.random() * 62); ch = dict[idx]; str += ch; &#125; return str;&#125;var str = getRandStr(10); // 0a3iJiRZap 4. 写一个函数，生成一个随机 IP 地址，一个合法的 IP 地址为 0.0.0.0~255.255.255.255 123456789function getRandIP()&#123; var obj = []; for(var i = 0; i &lt; 4; i++)&#123; obj[i] = Math.floor(Math.random() * 256); &#125; return obj.join(&apos;.&apos;);&#125;var ip = getRandIP()console.log(ip) // 10.234.121.45 5. 写一个函数，生成一个随机颜色字符串，合法的颜色为#000000~ #ffffff12345678910111213function getRandColor()&#123; var dict = &apos;0123456789abcdef&apos;; var len = dict.length; var ch, str = &apos;&apos;; for(var i = 0; i &lt; 6; i++)&#123; var idx = Math.floor(Math.random() * len); ch = dict[idx]; str += ch; &#125; return &apos;#&apos; + str;&#125;var color = getRandColor()console.log(color) // #3e2f1b 数组1. 数组方法里push、pop、shift、unshift、join、split分别是什么作用？用 splice函数分别实现push、pop、shift、unshift方法 push() 方法添加一个或多个元素到数组的末尾，并返回数组新的长度（length 属性值）。 pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。 shift() 方法从数组中删除第一个元素，并返回该元素。此方法更改数组的长度。 unshift() 方法在数组的开头添加一个或者多个元素，并返回数组新的 length 值。 join() 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中。 split（）方法通过将字符串分成子字符串，从而将一个String对象拆分为一个字符串数组。 splice() 方法通过删除现有元素和/或添加新元素来更改数组的内容。12345678910111213141516var arr = [1, 2, 3, 4, 5];//实现push()方法：arr.splice(5,0,6);console.log(arr);//[1, 2, 3, 4, 5, 6]//实现pop()方法：arr.splice(5,1);console.log(arr);//[1, 2, 3, 4, 5]//实现shift()方法：arr.splice(0,0,0);console.log(arr);//[0, 1, 2, 3, 4, 5]//实现unshift()方法：arr.splice(0,1);console.log(arr);//[1, 2, 3, 4, 5] 2. 写一个函数，操作数组，数组中的每一项变为原来的平方，在原数组上操作123456789function squareArr(arr)&#123; for(var i = 0; i &lt; arr.length; i++)&#123; arr[i] = arr[i] * arr[i]; &#125; return arr;&#125;var arr = [2, 4, 6]squareArr(arr)console.log(arr) // [4, 16, 36] 3. 写一个函数，操作数组，返回一个新数组，新数组中只包含正数，原数组不变12345678910111213function filterPositive(arr)&#123; var newArr = []; for(var i = 0; i &lt; arr.length; i++)&#123; if(typeof arr[i] === &apos;number&apos; &amp;&amp; arr[i] &gt; 0)&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;var arr = [3, -1, 2, &apos;饥人谷&apos;, true];var newArr = filterPositive(arr);console.log(newArr) //[3, 2]console.log(arr) //[3, -1, 2, &apos;饥人谷&apos;, true] Date1. 写一个函数getChIntv，获取从当前时间到指定日期的间隔时间123456789101112function getChIntv(time)&#123; var nowTime = Date.now(); var endTime = Date.parse(time) - 8*60*60*1000; var intTime = endTime - nowTime; var days = parseInt(intTime / (1000*60*60*24)); var hours =parseInt( (intTime % (1000*60*60*24)) / (1000*60*60)); var minutes = parseInt(((intTime % (1000*60*60*24)) % (1000*60*60)) / (1000*60)); var seconds = parseInt((((intTime % (1000*60*60*24)) % (1000*60*60)) % (1000*60)) / 1000); return &apos;距除夕还有 &apos;+days+&apos; 天 &apos;+hours+&apos; 小时 &apos;+minutes+&apos; 分 &apos;+seconds+&apos; 秒&apos;;&#125;var str = getChIntv(&quot;2017-02-08&quot;);console.log(str); // 距除夕还有 4 天 12 小时 16 分 14 秒 2. 把hh-mm-dd格式数字日期改成中文日期123456789101112131415161718function getChsDate(time)&#123; var dict = &apos;零,一,二,三,四,五,六,七,八,九,十,十一,十二,十三,十四,十五,十六,十七,十八,十九,二十,二十一,二十二,二十三,二十四,二十五,二十六,二十七,二十八,二十九,三十,三十一&apos;; dict = dict.split(&apos;,&apos;); var arr = time.split(&apos;-&apos;); var year = arr[0]; var month = arr[1]; var day = arr[2]; var yearCh = []; for(var i = 0; i &lt; 4; i++)&#123; yearCh.push(dict[parseInt(year[i])]); &#125; var monthCh = dict[parseInt(month)]; var dayCh = dict[parseInt(day)]; var str = yearCh.join(&apos;&apos;)+&apos;年&apos;+monthCh+&apos;月&apos;+dayCh+&apos;日&apos;; return str;&#125;var str = getChsDate(&apos;2015-01-08&apos;);console.log(str); // 二零一五年一月八日 3. 写一个函数，参数为时间对象毫秒数的字符串格式，返回值为字符串。假设参数为时间对象毫秒数t，根据t的时间分别返回如下字符串: 刚刚（ t 距当前时间不到1分钟时间间隔） 3分钟前 (t距当前时间大于等于1分钟，小于1小时) 8小时前 (t 距离当前时间大于等于1小时，小于24小时) 3天前 (t 距离当前时间大于等于24小时，小于30天) 2个月前 (t 距离当前时间大于等于30天小于12个月) 8年前 (t 距离当前时间大于等于12个月)12345678910111213141516171819function friendlyDate(time)&#123; var nowTime = Date.now(); var intTime = ( nowTime - time ) / 1000; var result; if(intTime &lt; 60)&#123; return result = &apos;刚刚&apos;; &#125;else if(intTime &lt; 60*60)&#123; return result = parseInt(intTime / 60) +&apos;分钟前&apos;; &#125;else if(intTime &lt; 60*60*24)&#123; return result = parseInt(intTime / (60*60)) +&apos;小时前&apos;; &#125;else if(intTime &lt; 60*60*24*30)&#123; return result = parseInt(intTime / (60*60*24)) +&apos;天前&apos;; &#125;else if(intTime &lt; 60*60*24*30*12)&#123; return result = parseInt(intTime / (60*60*24*30)) +&apos;个月前&apos;; &#125; return result = parseInt(intTime / (60*60*24*30*12)) +&apos;年前&apos;;&#125;var str = friendlyDate( &apos;1484286699422&apos; ) // 1分钟前var str2 = friendlyDate(&apos;1483941245793&apos;) //4天前]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符串与JSON]]></title>
    <url>%2F2017%2F05%2F11%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8EJSON%2F</url>
    <content type="text"><![CDATA[1. 使用数组拼接出如下字符串12345678910111213141516var prod = &#123; name: &apos;女装&apos;, styles: [&apos;短款&apos;, &apos;冬季&apos;, &apos;春装&apos;]&#125;;function getTplStr(data)&#123; var arr = []; arr.push(&apos;&lt;dl class=&quot;product&quot;&gt;&apos;+&apos;\n&apos;); arr.push(&apos;\t&apos;+&apos;&lt;dt&gt;&apos;+data.name+&apos;&lt;/dt&gt;&apos;+&apos;\n&apos;); for(var key in data.styles)&#123; arr.push(&apos;\t&apos;+&apos;&lt;dd&gt;&apos;+data.styles[key]+&apos;&lt;/dd&gt;&apos;+&apos;\n&apos;) &#125; arr.push(&apos;&lt;/dl&gt;&apos;); return arr.join(&apos;&apos;);&#125;;var result = getTplStr(prod); //result为下面的字符串console.log(result); 123456&lt;dl class=&quot;product&quot;&gt; &lt;dt&gt;女装&lt;/dt&gt; &lt;dd&gt;短款&lt;/dd&gt; &lt;dd&gt;冬季&lt;/dd&gt; &lt;dd&gt;春装&lt;/dd&gt;&lt;/dl&gt; 2. 写出两种以上声明多行字符串的方法 方法一：利用转义符\ 123456var longString = &quot;hello\ ji\ ren\ gu&quot;;longString// &quot;hello ji ren gu&quot; 方法二：利用连接运算符（+） 123456var longString = &apos;hello &apos; + &apos;ji &apos; + &apos;ren &apos; + &apos;gu&apos;;longString// &quot;hello ji ren gu&quot; 3. 补全如下代码,让输出结果为字符串: hello\饥人谷12var str = &apos;hello\\\\饥人谷&apos;console.log(str) 4. 以下代码输出什么?为什么123var str = &apos;jirengu\nruoyu&apos;console.log(str.length)//输出：13 使用了\n换行，占一个字符，空格不会计算在长度内 5. 写一个函数，判断一个字符串是回文字符串，如 abcdcba是回文字符串, abcdcbb不是 12345678910function fn(str)&#123; var str1 = str.split(&apos;&apos;).reverse().join(&apos;&apos;); if(str === str1)&#123; console.log(&apos;true&apos;) &#125;else&#123; console.log(&apos;false&apos;) &#125; &#125;fn(&apos;abcdcba&apos;)//turefn(&apos;abcdcbb&apos;)//false 6. 写一个函数，统计字符串里出现频率最多的字符12345678910111213141516171819function max(str) &#123; var obj = &#123;&#125;; for (var i = 0; i &lt; str.length; i++)&#123; if(obj[str[i]])&#123; obj[str[i]]++; &#125;else&#123; obj[str[i]] = 1; &#125; &#125; var sum = 0; var maxStr; for(var key in obj)&#123; if(obj[key] &gt; sum)&#123; sum = obj[key]; maxStr = key; &#125; &#125; return maxStr+&apos;:&apos;+sum;&#125; 7. 写一个camelize函数，把my-short-string形式的字符串转化成myShortString形式的字符串，如12345678910111213camelize(&quot;background-color&quot;) == &apos;backgroundColor&apos;camelize(&quot;list-style-image&quot;) == &apos;listStyleImage&apos;function camelize(str)&#123; var arr = []; for(var i = str.length-1; i &gt;= 0; i--)&#123; if(str[i-1] == &apos;-&apos;)&#123; arr.unshift(str[i].toUpperCase()); &#125;else&#123; arr.unshift(str[i]); &#125; &#125; return arr.join(&apos;&apos;).split(&apos;-&apos;).join(&apos;&apos;);&#125; 8. 写一个 ucFirst函数，返回第一个字母为大写的字符 （*）123456789ucFirst(&quot;hunger&quot;) == &quot;Hunger&quot;function ucFirst (str)&#123; var arr = []; arr.push(str[0].toUpperCase()); for(var i = 1; i &lt; str.length; i++)&#123; arr.push(str[i]); &#125; return arr.join(&apos;&apos;);&#125; 9. 写一个函数truncate(str, maxlength), 如果str的长度大于maxlength，会把str截断到maxlength长，并加上…，如1234567891011truncate(&quot;hello, this is hunger valley,&quot;, 10) == &quot;hello, thi...&quot;;truncate(&quot;hello world&quot;, 20) == &quot;hello world&quot;function truncate(str, maxlength)&#123; var str2; if(str.length &lt;= maxlength)&#123; str2 = str; &#125;else&#123; str2 = str.substr(0,maxlength)+&apos;...&apos;; &#125; return str2;&#125; 10. 什么是 json？什么是 json 对象？什么是 json 对象字面量？什么是 JSON内置对象？ JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于JavaScript（Standard ECMA-262 3rd Edition - December 1999）的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(网络传输速度)。 简单说，每个JSON对象，就是一个值。要么是简单类型的值，要么是复合类型的值，但是只能是一个值，不能是两个或更多的值。这就是说，每个JSON文档只能包含一个值。JSON对值的类型和格式有严格的规定： 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。 简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。 字符串必须使用双引号表示，不能使用单引号。 对象的键名必须放在双引号里面。 数组或对象最后一个成员的后面，不能加逗号。 空数组和空对象都是合格的JSON值，null本身也是一个合格的JSON值。 JSON对象字面量是一种简单的描述以及声明方式。 JSON是javascript中的内置对象，提供了JSON.parse()、JSON.stringify()等方法。 11. 如何把JSON 格式的字符串转换为对象？如何把对象转换为 JSON 格式的字符串?12345678var json = &#123; &quot;name&quot;: &quot;jirengu&quot;, &quot;age&quot;: 100&#125;;var json_str = JSON.stringify(json); //对象转为字符串console.log(json_str);console.log(JSON.parse(json_str)); //字符串转为对象]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[引用类型对象拷贝]]></title>
    <url>%2F2017%2F05%2F10%2F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[1. 引用类型有哪些？非引用类型有哪些 引用类型值（对象、数组、函数、正则）：指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象。 基本类型值（数值、布尔值、字符串、null和undefined）：指的是保存在栈内存中的简单数据段。 2. 如下代码输出什么？为什么12345var obj1 = &#123;a:1, b:2&#125;;var obj2 = &#123;a:1, b:2&#125;;console.log(obj1 == obj2); //输出：false obj1与0bj2指向不同的地址console.log(obj1 = obj2); //输出：&#123;a:1, b:2&#125; obj2赋值给obj1console.log(obj1 == obj2); //输出：ture obj1与obj2地址相同 3. 如下代码输出什么? 为什么 12345678910111213141516var a = 1var b = 2var c = &#123; name: &apos;饥人谷&apos;, age: 2 &#125;var d = [a, b, c]var aa = avar bb = bvar cc = cvar dd = da = 11b = 22c.name = &apos;hello&apos;d[2][&apos;age&apos;] = 3console.log(aa) //输出：1 基本类型 把a赋值给aaconsole.log(bb) //输出：2 同上console.log(cc) //输出：&#123;name: &quot;hello&quot;, age: 3&#125; 引用类型 地址相同 d[2][&apos;age&apos;] = 3 改变&apos;age&apos;值 console.log(dd) //输出：[1,2,&#123;name: &quot;hello&quot;, age: 3&#125;] 引用类型 地址相同 4. 如下代码输出什么? 为什么12345678910111213var a = 1var c = &#123; name: &apos;jirengu&apos;, age: 2 &#125;function f1(n)&#123; ++n&#125;function f2(obj)&#123; ++obj.age&#125;f1(a) f2(c) f1(c.age) console.log(a) //输出：1 基本类型 a的值赋给了n，++n变化n的值，a不会发生变化console.log(c) //输出：&#123;name: &apos;jirengu&apos;, age: 3&#125; 引用类型 c指向的地址赋值给了obj 5. 过滤如下数组，只保留正数，直接在原数组上操作1234567891011var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt;= 0)&#123; arr.splice(i, 1); filter(arr); &#125; &#125;&#125;filter(arr)console.log(arr) // [3,1,2] 6. 过滤如下数组，只保留正数，原数组不变，生成新数组123456789101112131415var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; var newArr = []; var j = 0; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; 0 ) &#123; newArr[j] = arr[i]; j++; &#125; &#125; return newArr;&#125;var arr2 = filter(arr)console.log(arr2) // [3,1,2]console.log(arr) // [3,1,0,-1,-2,2,-5] 7. 写一个深拷贝函数，用两种方式实现12345678910111213141516171819第一种function deepCopy(oldObj)&#123; var newObj = &#123;&#125;; for(var key in oldObj)&#123; if(typeof oldObj[key] === &apos;number&apos; || typeof oldObj[key] === &apos;string&apos; || typeof oldObj[key] === &apos;boolen&apos; || oldObj[key] === null || oldObj[key] === undefined)&#123; newObj[key] = oldObj[key]; &#125; else&#123; newObj[key] = deepCopy(oldObj[key]); &#125; &#125; return newObj;&#125;第二种 function deepCopy(oldObj)&#123; var newObj = JSON.parse(JSON.stringify(oldObj)); return newObj; &#125;]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数与作用域]]></title>
    <url>%2F2017%2F05%2F10%2F%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[1. 函数声明和函数表达式有什么区别 函数声明必须带有标示符（Identifier）（即函数名称），而函数表达式则可以省略这个标示符。 函数声明:function functionName(){} function 函数名称 (参数：可选){ 函数体 }函数表达式：var fn = function(){}function 函数名称（可选）(参数：可选){ 函数体 } 函数声明语句中的函数名是一个变量名，变量指向函数对象。函数定义表达式和通过var声明变量一样，其函数被提前到了脚本或函数的顶部，因此它在整个脚本和或函数内都是可见的。这样的话，只有函数变量声明提前了，函数的初始化代码仍然在原来的位置。但是使用函数声明的话，函数名称和函数体均提前了，即脚本中的函数和函数中嵌套的函数都会在当前上下文中其它代码之前声明，也即可以在声明一个函数之前调用它。 2. 什么是变量的声明前置？什么是函数的声明前置 变量声明前置：JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部。12console.log(a);var a = 1; 即123var a;console.log(a);a = 1; 函数声明前置：JavaScript引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。12f();function f() &#123;&#125; 3. arguments 是什么 arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。123456789var f = function(one) &#123; console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]);&#125;f(1, 2, 3)// 1// 2// 3 4. 函数的”重载”怎样实现 重载是很多面向对象语言实现多态的手段之一，在静态语言中确定一个函数的手段是靠方法签名——函数名+参数列表，也就是说相同名字的函数参数个数不同或者顺序不同都被认为是不同的函数，称为函数重载。 在JavaScript中没有函数重载的概念，函数通过名字确定唯一性，参数不同也被认为是相同的函数，后面的覆盖前面的，但可以在函数体针对不同的参数调用执行相应的逻辑。12345678910111213function printPeopleInfo(name, age, sex)&#123; if(name)&#123; console.log(name); &#125; if(age)&#123; console.log(age); &#125; if(sex)&#123; console.log(sex); &#125;&#125;printPeopleInfo(&apos;Byron&apos;, 26);printPeopleInfo(&apos;Byron&apos;, 26, &apos;male&apos;); 5. 立即执行函数表达式是什么？有什么作用 立即执行函数表达式（Immediately-Invoked Function Expression），简称IIFE。表示定义函数之后，立即调用该函数。 123(function()&#123; var a = 1;&#125;)() 其他写法： 123(function fn1() &#123;&#125;);[function fn2() &#123;&#125;];1, function fn3() &#123;&#125;; 作用：隔离作用域。 6. 求n!，用递归来实现123456function factor(n)&#123; if(n === 1) &#123; return 1 &#125; return n * factor(n-1)&#125; 7. 以下代码输出什么？1234567891011121314 function getInfo(name, age, sex)&#123; console.log(&apos;name:&apos;,name); console.log(&apos;age:&apos;, age); console.log(&apos;sex:&apos;, sex); console.log(arguments); arguments[0] = &apos;valley&apos;; console.log(&apos;name&apos;, name); &#125;getInfo(&apos;饥人谷&apos;, 2, &apos;男&apos;);/* 输出：name:饥人谷 age:2 sex:男 [&quot;饥人谷&quot;,2,&quot;男&quot;] name valley */getInfo(&apos;小谷&apos;, 3);/* 输出：name:小谷 age:3 sex:undefined [&quot;小谷&quot;,3] name valley */getInfo(&apos;男&apos;);/* 输出：name:男 age:undefiend sex:undefined [&quot;男&quot;] name valley */ 8. 写一个函数，返回参数的平方和？1234567891011function sumOfSquares()&#123; var result=0; for(var i=0;i&lt;arguments.length;i++)&#123; result=result+arguments[i]*arguments[i]; &#125; console.log(result);&#125;var result = sumOfSquares(2,3,4)var result2 = sumOfSquares(1,3)console.log(result) //29console.log(result) //10 9. 如下代码的输出？为什么1234console.log(a);var a = 1;console.log(b);/* 输出：undefined 报错：b is not defined 原因：变量提升，没有b变量的声明*/ 10. 如下代码的输出？为什么12345678sayName(&apos;world&apos;);//输出：hello world 函数声明前置sayAge(10);//报错：sayAge is not a function 函数表达式不前置function sayName(name)&#123; console.log(&apos;hello &apos;, name);&#125;var sayAge = function(age)&#123; console.log(age);&#125;; 11. 如下代码输出什么? 写出作用域链查找过程伪代码123456789101112131415161718192021222324252627282930313233var x = 10bar() function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo()&#125;/* 输出：101.globalContext = &#123; AO: &#123; x: 10 foo: function bar: function &#125; Scope: null&#125;foo.[[scope]] = globalContext.AObar.[[scope]] = globalContext.AO2.调用bar()barContext = &#123; AO: &#123; x: 30 &#125; Scope: bar.[[scope]] = globalContext.AO&#125;3.调用foo()fooContext = &#123; AO: &#123;&#125; Scope: foo.[[scope]] = globalContext.AO&#125; */ 12. 如下代码输出什么? 写出作用域链查找过程伪代码123456789101112131415161718192021222324252627282930313233var x = 10;bar() function bar()&#123; var x = 30; function foo()&#123; console.log(x) &#125; foo();&#125;/* 输出：301.globalContext = &#123; AO: &#123; x: 10 bar: function &#125; Scope: null&#125;bar.[[scope]] = globalContext.AO2.调用bar()barContext = &#123; AO: &#123; x: 30 foo: function &#125; Scope: bar.[[scope]] = globalContext.AO&#125;foo.[[scope]] = barContext.AO3.调用foo()fooContext = &#123; AO: &#123;&#125; Scope: foo.[[scope]] = barContext.AO&#125; */ 13. 以下代码输出什么? 写出作用域链的查找过程伪代码1234567891011121314151617181920212223242526272829303132var x = 10;bar() function bar()&#123; var x = 30; (function ()&#123; console.log(x) &#125;)()&#125;/* 输出：301.globalContext = &#123; AO: &#123; x: 10 bar: function &#125; Scope: null&#125;bar.[[scope]] = globalContext.AO2.调用bar()barContext = &#123; AO: &#123; x: 30 function()&#123;&#125; &#125; Scope: bar.[[scope]] = globalContext.AO&#125;function.[[scope]] = barContext.AO3.调用function()functionContext = &#123; AO: &#123;&#125; Scope: function.[[scope]] = barContext.AO&#125; */ 14. 以下代码输出什么？ 写出作用域链查找过程伪代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var a = 1;function fn()&#123; console.log(a) var a = 5 console.log(a) a++ var a fn3() fn2() console.log(a) function fn2()&#123; console.log(a) a = 20 &#125;&#125;function fn3()&#123; console.log(a) a = 200&#125;fn()console.log(a)/* 输出： undefined 5 6 1 20 2001.globalContext = &#123; AO: &#123; a: 1 ==&gt;a: 200 fn: function fn3: function &#125; Scope: null&#125;fn.[[scope]] = globalContext.AOfn3.[[scope]] = globalContext.AO2.调用fn()fnContext = &#123; AO: &#123; a: undefined(输出：undefined)==&gt;5(输出：5)==&gt;6 fn2: function &#125; Scope: fn.[[scope]] = globalContext.AO&#125;fn2.[[scope]] = fnContext.AO3.调用fn3()fn3Context = &#123; AO: &#123;&#125; Scope: fn3.[[scope]] = globalContext.AO&#125;输出：14.调用fn2()fn2Context = &#123; AO: &#123;&#125;输出：6 ==&gt;a: 20(输出：20) Scope: fn2.[[scope]] = fnContext.AO&#125;5.console.log(a) 输出：200 */]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据类型&运算符&流程控制语句]]></title>
    <url>%2F2017%2F05%2F10%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E8%BF%90%E7%AE%97%E7%AC%A6-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[1. JavaScript定义了几种数据类型?哪些是原始类型?哪些是复杂类型?原始类型和复杂类型的区别是什么? JavaScript的数据类型，共有六种。 数值（number）：整数和小数 字符串（string）：字符组成的文本 布尔值（boolean）：true（真）和false（假）两个特定值 undefined：表示“未定义”或不存在，即此处目前没有任何值 null：表示空缺，即此处应该有一个值，但目前为空 对象（object）：各种值组成的集合，又可以分为以下子类型： 狭义的对象（object） 数组（array） 函数（function） 正则表达式（regexp） Symbol：生成一个全局唯一的值。 原始类型（primitive type）的值：数值、字符串、布尔值，它们是最基本的数据类型，不能再细分了。 复杂类型（complex type）的值：对象，对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。 特殊值：undefined和null。 原始类型和复杂类型的区别: 基本类型变量存的是值，复杂类型的变量存的是内存地址。 基本类型在赋值的时候拷贝值，复杂类型在赋值的时候只拷贝地址，不拷贝值。 2. typeof和instanceof的作用和区别? typeof运算符可以返回一个值的数据类型，可能有以下结果: 数值、字符串、布尔值分别返回number、string、boolean。 函数返回function。 undefined返回undefined。 typeof可以用来检查一个没有声明的变量，而不报错。实际编程中，这个特点通常用在判断语句。 除此以外，其他情况都返回object。 如果我们希望获取一个对象是否是数组，或判断某个变量是否是某个对象的实例则要选择使用instanceof。instanceof通过返回一个布尔值来判断一个变量是否某个对象的实例。 3. 如何判断一个变量是否是数字、字符串、布尔、函数 使用typeof运算符1234typeof 123 === &apos;number&apos; //判断是否为数字typeof &apos;123&apos; === &apos;string&apos; //判断是否为字符串typeof false ===&apos;boolean&apos; //判断是否为布尔typeof v ===&apos;function&apos; //判断是否为函数 4. NaN是什么? 有什么特别之处? NaN：Not a Number，表示非数字，NaN和任何值都不相等，包括自己 5. 如何把非数值转化为数值? 有三个函数可以把非数值转换为数值 Number() parseInt() parseFloat Number规则相当复杂而且不合理，几乎不使用，常用的是后两个，且规则类似 忽略字符串前面的空白字符，找到第一个非空白字符 如果第一个字符不是-或者数字返回NaN 如果是继续解析，直到非数值模式为止 0开头会当做八进制，0x开头会当做十六进制，但是可以指定第二个参数指定基数 6. ==与===有什么区别 ===是严格意义的相等，只需注意NaN和NaN不等。 使用==时，javascript会进行类型转换： 如果两个值类型相同，则执行严格相等的运算 如果两个值的类型不同 如果一个是null，一个是undefined，那么相等 如果一个是数字，一个是字符串，先将字符串转为数字，然后比较 如果一个值是true/false则将其转为1/0比较 如果一个值是对象，一个是数字或字符串，则尝试使用valueOf和toString转换后比较 其它就不相等了 7. break与continue有什么区别 break 用于强制退出循环体，执行循环后面的语句 continue 用于退出本次循环，执行下次循环 8. void 0 和 undefined在使用场景上有什么区别 undefined 可以在局部作用域中被覆写 void 运算返回值始终都是 undefined 9. 以下代码的输出结果是?为什么?1234console.log(1+1); //2 两个操作数都是数字，加法运算 console.log(&quot;2&quot;+&quot;4&quot;); //&quot;24&quot; 两个参数都是字符串,字符串拼接 console.log(2+&quot;4&quot;); //&quot;24&quot; 有一个参数是字符串,会把另外一个参数转换为字符串进行拼接console.log(+&quot;4&quot;); //4 只有一个字符串，将其转换为数字 10. 以下代码的输出结果是?123var a = 1; a+++a; //输出3，a++优先级高，运算结果为1，此时a=2,所以输出3typeof a+2; //输出&quot;number2&quot;,typeof优先级高，输出字符串&quot;number&quot;,然后与数字2相加，数字转换为字符串然后拼接 11. 以下代码的输出结果是? 为什么123var a = 1;var b = 3;console.log( a+++b );//输出4，a++优先级高，运算结果为1，然后与b相加 12. 遍历数组，把数组里的打印数组每一项的平方123var arr = [3,4,5]//for(var i = 0; i &lt; arr.length; i++)&#123;console.log(arr[i]*arr[i])&#125;//输出结果：9 16 25 13. 遍历 JSON, 打印里面的值123456var obj = &#123; name: &apos;hunger&apos;, sex: &apos;male&apos;, age: 28 &#125;//for(var key in obj)&#123;console.log(obj[key])&#125; 14. 以下代码输出结果是? 为什么123456789101112131415161718var a = 1, b = 2, c = 3;var val = typeof a + b || c &gt;0console.log(val) //优先级：typeof, +, &gt;, || 依次运算输出结果为：number2var d = 5;var data = d ==5 &amp;&amp; console.log(&apos;bb&apos;) console.log(data) //输出：bb undefined console.log(&apos;bb&apos;)先执行输出bb,&amp;&amp;前为ture,则返回console.log(&apos;bb&apos;)的值，即返回undefined,所以data为undefined(&amp;&amp;（短路）=&gt;如果第一个值为true则返回第二个值；如果第一个值为false则返回第一个值)var data2 = d = 0 || console.log(&apos;haha&apos;)console.log(data2)//输出：haha undefined console.log(&apos;haha&apos;)先执行输出haha,||优先级高于=，比较0(false)和console.log(&apos;haha&apos;)，输出undefined,右结合赋值给data2,所以data2为undefined(||（短路）=&gt;如果第一个值为true则返回第一个值；如果第一个值为false则返回第二个值) var x = !!&quot;Hello&quot; + (!&quot;world&quot;, !!&quot;from here!!&quot;);console.log(x)//输出：2 !&quot;world&quot;为false, !!&quot;from here!!&quot;为ture, !!&quot;Hello&quot;为ture, 所以为ture+ture, 输出为2]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS相关概念]]></title>
    <url>%2F2017%2F05%2F09%2FJS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1. CSS和JS在网页中的放置顺序是怎样的？ 一般将css放置head里用style包裹，也可以使用link标签引入。 js使用script标签引入且一般放置在body闭合标签之前。 2. 解释白屏和FOUC1.白屏 如果把样式放在底部，对于IE浏览器，chrome等（CSS全部加载后再呈现,有可能等待时间长），在某些场景下(新窗口打开，刷新等)页面会出现白屏，而不是内容逐步展现。 使用@import标签，即使CSS放入link, 并且放在头部,也可能出现白屏。 对于图片和CSS, 在加载时会并发加载(如一个域名下同时加载两个文件)。 但在加载JavaScript时，会禁用并发，并且阻止其他内容的下载。所以把JavaScript放入页面顶部也会导致白屏现象。 2.FOUC Flash of Unstyled Content “无样式内容闪烁“：有些浏览器是边渲染边呈现，CSS放置body标签底部，会出现加载html结束后才一次性加载css样式，从而导致页面闪烁。 3. async和defer的作用是什么？有什么区别 &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 &lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 &lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 从实用角度来讲，首先把所有脚本都放置到 &lt;/body&gt; 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。 由图得知： defer 和 async 在网络读取（下载）这部分是一样的，都是异步的（相较于 HTML 解析）。 两者的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的。 关于 defer，由图知它是按照加载顺序执行脚本的，这一点要善加利用。 async 则是乱序执行，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行。 async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics。 4. 简述网页的渲染机制 解析 HTML 标签, 构建 DOM 树 解析 CSS 标签, 构建 CSSOM 树 把 DOM 和 CSSOM 组合成 渲染树 (render tree) 在渲染树的基础上进行布局, 计算每个节点的几何结构 把每个节点绘制到屏幕上 (painting)]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS规范&垂直居中]]></title>
    <url>%2F2017%2F05%2F09%2FCSS%E8%A7%84%E8%8C%83-%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[1. 说一说你平时写代码遵守的编码规范 关于命名 语义化标签优先 命名体现功能，不涉及表现样式(颜色、字体、边框、背景等) 所有命名都使用英文小写 命名用引号包裹 用中横线连接 关于html与css 嵌套元素应当缩进一次（即两个空格） 减少标签的数量 为选择器分组时，将单独的选择器单独放在一行。 css的 :后加个空格， {前加个空格 每条声明后都加上分号 换行，而不是放到一行 颜色用小写，用缩写, #fff 小数不用写前缀, 0.5s -&gt; .5s；0不用加单位 尽量缩写， margin: 5px 10px 5px 10px -&gt; margin: 5px 10px 遵守编码规范bootstrap 2. 垂直居中有几种实现方式，给出代码范例 height=line-height实现单行文本垂直居中： demo 利用padding值相等实现：demo 绝对定位 利用负margin demo 利用transform demo 利用margin: auto demo vertical-align: middle demo dispaly: table-cell demo]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容]]></title>
    <url>%2F2017%2F05%2F09%2FCSS%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[1. 什么是 CSS hack 由于不同厂商的浏览器或某浏览器的不同版本（如IE6-IE11/Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器或不同版本写相应的CSS code的过程，叫做CSS hack。 CSS hack大致有3种表现形式，CSS属性前缀法、选择器前缀法以及IE条件注释法（即HTML头部引用if IE）hack，实际项目中CSS hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。 2. 谈一谈浏览器兼容的思路 要不要做？ 产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先） 成本的角度 (有无必要做) 做到什么程度？ 让哪些浏览器支持哪些效果 如何做？ 明确效果是要优雅降级还是渐进增强：1.渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。2.优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 根据兼容需求选择技术框架/库(jquery) 根据兼容需求选择兼容工具(html5shiv.js、respond.js、css reset、normalize.css、Modernizr) postCSS 条件注释、CSS Hack、js 能力检测做一些修补 3. 列举5种以上浏览器兼容的写法 inline-block不兼容IE6、7，兼容写法： 12345div &#123; display: inline-block; *zoom: 1; *display: inline;&#125; IE6、7清除浮动： 12345678.clearfix:after&#123; content: &apos;&apos;; display: block; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125; 浮动元素双倍margin： 123456.content &#123; float: left; width: 200px; margin-left: 10px; display: inline;&#125; 设置元素的最小高度(min-height)： 12345.ct &#123; min-height: 500px; height: auto !important; height: 500px;&#125; 禁用IE默认的垂直滚动条： 123html &#123; overflow: auto;&#125; 4. 以下工具/名词是做什么的？ 条件注释用于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码。使用了条件注释的页面在IE9中可正常工作，但在IE10中无法正常工作。 IE10不再支持条件注释。 IE Hack针对IE浏览器的不同版本去写不同的CSS，让它能在这些浏览器中得到我们想要的页面效果。常用方法：CSS属性前缀法、选择器前缀法以及IE条件注释法。 js 能力检测使用js检测浏览器支持的属性，以便展示效果。目标不是识别特定的浏览器，而是识别浏览器的能力。 html5shiv.js通过使用html5shiv.js让IE9以下版本浏览器支持所有的HTML5标签。 respond.jsrespond.js让不支持css3 Media Query的浏览器包括IE6-IE8支持查询。 css resetcss reset(css重置、清除css样式)重置样式，清除浏览器默认样式。 normalize.cssnormalize.css 是一个可以定制的CSS文件，它让不同的浏览器在渲染网页元素的时候形式更统一。 ModernizrModernizr是一个开源的JS库，它使得那些基于访客浏览器的不同（指对新标准支持性的差异）而开发不同级别体验的设计师的工作变得更为简单。它使得设计师可以在支持HTML5和CSS3的浏览器中充分利用HTML5和CSS3的特性进行开发，同时又不会牺牲其他不支持这些新技术的浏览器的控制。 postCSSPostCSS可以直观的理解为：它就是一个平台；PostCSS提供了一个解析器，它能够将CSS解析成抽象语法树（AST）；通过在PostCSS这个平台上，能够开发一些插件，来处理CSS，比如热门的：autoprefixer；能够使用JavaScript来开发插件。]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浮动定位&BFC&边距合并]]></title>
    <url>%2F2017%2F05%2F09%2F%E6%B5%AE%E5%8A%A8%E5%AE%9A%E4%BD%8D-BFC-%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[1. 浮动元素有什么特征？对父容器、其他浮动元素、普通元素、文字分别有什么影响? 浮动元素会脱离正常的文档流，使其浮动到父元素的行的一端(元素向左或向右移动，直到碰到浮动元素，或者达到父元素内容的边界，不包括padding)，并且其他元素将忽略该浮动元素并填补其原先的空间。 对父容器的影响：元素浮动后，会脱离正常文档流，在原文档中，该浮动元素似乎消失了，因此它不能撑开父元素，容易造成父元素的塌陷。 对其他浮动元素的影响：若是同一方向浮动：兄弟元素相对该浮动元素按照从左到右(float:left)或者从右到左(float:right)的顺序依次排列。若是反方向浮动：兄弟元素和浮动元素将组成两个向左或向右的浮动队列，分别相对浮动方向同时向行中间浮动。他们尽可能处于同一行，如果行的宽度不足以容纳这两个队列，两个队列将错开成两行。 对普通元素的影响：若是块级元素：该块级元素会忽视浮动元素而占据它的位置，并且该块级元素会处于浮动元素的下层(并且无法通过z-index属性改变他们的层叠关系)，然而它的内容文字和其他行内元素将会环绕浮动元素。若是内联元素：内联元素将环绕浮动元素排列。 对文字的影响：文字将环绕浮动元素排列。 2. 清除浮动指什么? 如何清除浮动? 两种以上方法 清理浮动指解决float所导致的父元素塌陷问题。 清除浮动方法： 设置clear属性 父元素形成BFC，设置的方法有： float: left/right overflow: hidden/auto/scroll display: table-cell/table-caption/inline-block position: absolute/fixed 相对较好的方法：设置伪元素 方法一： 12345678.clearfix&#123; *zoom:1; &#125;.clearfix:after&#123; content:&quot;&quot;; display:block; clear:both; &#125; 方法二： 12345678.clearfix&#123; *zoom:1; &#125;.clearfix:after&#123; content:&quot;&quot;; display:table; clear:both; &#125; 3. 有几种定位方式，分别是如何实现定位的，参考点是什么，使用场景是什么？ position: absolute relative fixed sticky inherit static 1.position: relative 相对定位 不脱离文档流的布局，只改变自身的位置，在文档流原来的位置遗留空白区域。定位的起始位置为此元素原来在文档流中的位置。 使用场景：微调元素位置。 2.position: absolute 绝对定位 脱离文档流的布局，遗留下来的空间由后面的元素填充。定位的起始位置为最近的父元素(postion不为static)，否则为Body文档本身。 使用场景：常在页面布局中使用。 3.position: fixed 固定定位 脱离文档流的布局，空间由后面的元素填充。相对于浏览器窗口进行定位，不随着滚动条的移动而改变位置。 使用场景：登录框覆盖层、广告、回到顶部标签等。 4. z-index 有什么作用? 如何使用? z-index属性适用于定位元素（position属性值为relative 或absolute或fixed的对象），用来确定定位元素在垂直于显示屏方向（称为Z轴）上的层叠顺序，也就是说如果元素是没有定位的，对其设置的z-index会是无效的。 拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 5. position:relative和负margin都可以使元素位置发生偏移?二者有什么区别 positon:relative元素偏移后不脱离文档流，保留空间，不会影响其他元素； 负margin元素偏移后移动原来的空间，影响文档流中其他元素的位置。 6. BFC 是什么？如何生成 BFC？BFC 有什么作用？举例说明 BFC(Block Format Content):块级格式化上下文，它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 布局规则1.内部的Box会在垂直方向，一个接一个地放置。2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。4.BFC的区域不会与float box重叠。5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。6.计算BFC的高度时，浮动元素也参与计算。 如何生成BFC：父元素设置： float: left/right overflow: hidden/auto/scroll display: table-cell/table-caption/inline-block position: absolute/fixed 作用：1.BFC的区域不会与float box重叠。我们可以通过通过触发main生成BFC，来实现自适应两栏布局。demo2.清除内部浮动demo3.防止垂直 margin 重叠demo 7. 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例 外边距合并指的是：当两个垂直外边距相遇时，它们将合并形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距高度中的较大者。1.当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。2.当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上/或下外边距也会发生合并。（父子）3.假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并。4.外边距合并时递归的，如果这个外边距遇到另一个元素的外边距，它还会发生合并。 如何避免：1.为父元素设置BFC或padding或border2.兄弟元素间设置float或display:inline-block或positon:absulutedemo]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS常见样式2]]></title>
    <url>%2F2017%2F05%2F09%2FCSS%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F2%2F</url>
    <content type="text"><![CDATA[1. 盒模型包括哪些属性 content(内容) padding(内边距) border(边框) margin(外边距) 2. text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中 作用于块级元素，可以使块级元素中的inline、inline-block及文本水平居中 3. IE盒模型和W3C盒模型有什么区别? IE盒模型(怪异模式)：width=content+padding+border W3C标准盒模型：width=content IE678版本在不添加doctype时为怪异模式，添加doctype变成标准模式 使用box-sizing:border-box进行盒模型模式切换 4. 以下代码的作用？兼容性？123*&#123; box-sizing: border-box;&#125; 盒模型切换为怪异模式，即width=content+padding+border 兼容性 5. inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐? 内联块：将对象呈递为内联元素，但是对象的内容作为块级元素呈递。旁边的内联元素会被呈递在同一行内，允许空格。即同时具有内联元素和块级元素的特性。 去除缝隙的方法：1.移除标签段之间的空格2.使用margin负值1234.space a &#123; display: inline-block; margin-right: -3px;&#125; 3.删除闭合标签4.使用font-size:0123456.space &#123; font-size: 0;&#125;.space a &#123; font-size: 12px;&#125; 5.使用letter-spacing123456.space &#123; letter-spacing: -3px;&#125;.space a &#123; letter-spacing: 0;&#125; 6.使用word-spacing123456.space &#123; word-spacing: -6px;&#125;.space a &#123; word-spacing: 0;&#125; 顶端对齐：vertical-align:top; 6. CSS sprite 是什么? CSS sprite 即精灵图，雪碧图。是一种网页图片应用处理方式。它可以将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。 优点 利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能。 CSS Sprites能减少图片的字节。 解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率。 更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变，维护起来更加方便。 缺点 在图片合并的时候，需要把多张图片有序的合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景；若是在宽屏，高分辨率的屏幕下的自适应页面，图片如果不够宽，很容易出现背景断裂。 CSS Sprites在开发的时候比较麻烦。 CSS Sprites在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片。]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS常见样式]]></title>
    <url>%2F2017%2F05%2F08%2FCSS%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 块级元素和行内元素分别有哪些？动手测试并列出4条以上的特性区别 块级元素：h1,p,div,table,ul,li,ol,hr,form,dd,dt,tr,td,th 行内元素：img,span,em,strong,a,br,input,lable,select,textarea,code 特性区别： 块级元素会独占一行，默认情况下，其宽度自动填满其父元素宽度；行内元素不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下，才会换行，其宽度随元素的内容而变化 块级元素可以包含块级元素和行内元素，行内只能包含文本和行内元素 块级元素可以设置width，height属性，行内元素设置width，height属性无效 块级元素可以设置margin和padding属性，行内元素的margin和padding属性，水平方向产生效果，但竖直方向不会产生效果 块级元素对应于display:block；行内元素对应于display:inline 2. 什么是 CSS 继承? 哪些属性能继承，哪些不能？ css继承指设置上级(父级)的CSS样式，上级（父级）及以下的子级（下级）都具有此属性 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-break-before和unicode-bidi。 所有元素可继承：visibility和cursor。 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。 块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承：border-collapse。 3. 如何让块级元素水平居中？如何让行内元素水平居中? 块级元素： (需设置固定宽度)对子元素设置margin: 0 auto (不确定宽度)将元素放置在table中，再将table的margin-left和margin-right设置成auto，将table居中,使在其之中的块级元素也居中 将块级元素转换为行内元素(通过设置display:inline)后再居中 把父元素增加float:left，同时设置position:relative和left:50%。而子元素设置position:absolute和left:-50%来实现水平居中 行内元素：在父元素中设置text-align: center 4. 单行文本溢出加 …如何实现? 核心代码123white-space: nowrap;overflow: hidden;text-overflow: ellipsis; 5. px, em, rem 有什么区别 css单位 名称 相同点 不同点 px 像素(Pixel) 相对单位 px的值准确稳定，相对于屏幕分辨率 em em 相对单位 相对于父级元素的字体大小(继承性)，即em的值是不固定的，它随着其父级元素的变化而变化 rem 根(root)em 相对单位 相对于html根元素的字体大小，rem的值是不固定的，它随着html根元素的变化而变化，不受父级元素的影响]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2F2017%2F05%2F08%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. class 和 id 的使用场景? class: 标签的类名，具有普遍性，不唯一，可重复使用，所以尽量在结构内部使用，通常用于样式定义 id: 指定标签的唯一标识，具有唯一性，所以尽量在结构外围使用，通常用于页面布局 id的样式优先级高于class 2. CSS选择器常见的有几种? 基本选择器 通配选择器 * 元素选择器 Element ID选择器 #id 类选择器 .class 组合选择器 多元素选择器 E,F 后代选择器 E F 子选择器 E&gt;F 相邻兄弟选择器 E+F 通用兄弟选择器 E~F 伪类选择器 动态伪类选择器E:link,E:visited,E:active,E:hover,E:focus 目标伪类选择器E:target 语言伪类选择器E:lang(language) 状态伪类选择器E:checked,E:enabled,E:disabled 结构伪类选择器E:first-child,E:last-child,E:root,E:nth-child(n),E:nth-last-child(n),E:nth-of-type(n),E:nth-last-of-type(n),E:first-of-type,E:last-of-type,E:only-child,E:only-of-type,E:empty 伪元素 ::first-letter,::first-line,::before,::after,::selection 属性选择器 E[attr],E[attr=val],E[attr|=val],E[attr~=val],E[attr*=val],E[attr^=val],E[attr$=val] 3. 选择器的优先级是怎样的?对于复杂场景如何计算优先级？ 优先级从高到低 !important 1,0,0,0,0 style内联样式 1,0,0,0 id选择器 0,1,0,0 类选择器 0,0,1,0 伪类选择器 0,0,1,0 属性选择器 0,0,1,0 标签选择器、伪元素 0,0,0,1 通配符选择器 0,0,0,0 浏览器自定义 对于复杂场景计算优先级：选择器的权值加到一起，大的优先；如果权值相同，后定义的优先 。 4. a:link, a:hover, a:active, a:visited 的顺序是怎样的？ 为什么？ 正确的顺序：a:link、a:visited、a:hover、a:active 原因：浏览器解释CSS时遵循“就近原则” 记忆技巧：”爱恨原则”：LoVe/HAte (LVHA) 5. 以下选择器分别是什么意思?#header{} 选择id为header的元素.header{} 选择class为header的元素.header .logo{} 选择class为header的元素中class为logo的元素.header.mobile{} 选择class同时为header和mobile的元素.header p, .header h3{} 选择class为header元素中的p和h3元素#header .nav&gt;li{} 选择id为header的元素中class为nav的直接子元素li#header a:hover{} 选择id为header的元素中a链接的hover状态#header .logo~p{} 选择id为header的元素中与class为logo的元素同级的p元素#header input[type=&quot;text&quot;]{} 选择id为header的元素中type=”text”的input标签 6. 列出你知道的伪类选择器E:link 匹配所有未被点击的链接E:visited 匹配所有已被点击的链接E:active 匹配鼠标已经按下、还没有释放的E元素E:hover 匹配鼠标悬停其上的E元素E:focus 匹配获得当前焦点的E元素E:enabled 匹配表单中可用的元素E:disabled 匹配表单中禁用的元素E:checked 匹配表单中被选中的radio或checkbox元素E::selection 匹配用户当前选中的元素E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)E:empty 匹配一个不包含任何子元素的元素，文本节点也被看作子元素 7. div:first-child和div:first-of-type的作用和区别 :first-child 匹配的是其父元素的第一个子元素，即结构上的第一个子元素。 :first-of-type 匹配的是其父元素下相同类型子元素中的第一个，这里不再限制是第一个子元素，只要是该类型元素的第一个就可以。]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[line-height & a 标签]]></title>
    <url>%2F2017%2F05%2F08%2Fline-height-a%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[1. line-height有什么作用?line-height: 2和line-height: 200%有什么区别? 设置行高 实现单行文本的垂直居中 line-height详细用法 取值为数字时：行高=子元素字体大小*数字 取值为百分比时：行高=父元素字体大小*百分比 2. 如何去查CSS属性的兼容性？比如inline-block哪些浏览器支持？ 查询兼容性网址Can I Use 3. 关于a标签 href, title, target是什么？ href：Hypertext Reference，即超文本引用，用于指定超链接目标的URL 值 描述 URL 超链接的URL。可能的值：绝对URL:指向另一个站点（比如 href=&quot;http://www.example.com/index.html&quot;）相对URL:指向站点内的某个文件（href=&quot;index.html&quot;）锚 URL:指向页面中的锚（href=&quot;#top&quot;） title:标题，成为链接的默认名称。把鼠标悬停链接上面时，会显示title的内容，以达到补充说明或者提示的效果。 属性 值 描述 dir rtl/ltr 规定元素中内容的文本方向 lang language_code 规定元素中内容的语言代码 xml:lang language_code 规定 XHTML 文档中元素内容的语言代码 target:规定在何处打开链接文档 值 描述 _blank 在新窗口中打开被链接文档 _self 默认。在相同的框架中打开被链接文档 _parent 在父框架集中打开被链接文档 _top 在整个窗口中打开被链接文档 framename 在指定的框架中打开被链接文档 2.title和alt有什么区别？ 使用alt属性是为了给那些不能看到文档中图像的浏览者提供文字说明，是图像无法显示时的替代文本，所以alt是替代图像作用而不是提供额外说明文字的。 title属性是对元素的注释说明和额外补充，当鼠标放到文字或是图片上时有title文字显示。 3.如何新窗口打开链接？&lt;a href=&quot;http://www.example.com/&quot; target=&quot;_blank&quot;&gt;EXAMPLE&lt;/a&gt; 4. display: none , visibility: hidden, opacity:0 有什么作用？有什么区别？ 方法 作用描述 事件响应 display: none 使元素隐藏；元素空间被占用；导致浏览器重绘及重排 不会触发点击事件 visibility(能见度): hidden 使元素隐藏；元素空间不被占用；导致浏览器重绘不重排 不会触发点击事件 opacity(不透明度):0 使元素透明度为0，表现为隐藏；元素空间不被占用；不导致浏览器重绘及重绘 触发点击事件 background-color:rgba(0,0,0,0) 背景色透明 触发点击事件 5. 如何去除 a 链接的默认样式？直接在 a 链接父容器添加颜色，能否继承到当前 a 链接上？ 去除a链接的默认样式：a{text-decoration: none;} 不能继承到当前a链接上，需要为其单独设置]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2F2017%2F05%2F07%2FCSS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 样式有几种引入方式? 内联方式内联方式指的是直接在HTML标签中的style属性中添加CSS。示例：&lt;div style=&quot;background: red&quot;&gt;&lt;/div&gt; 嵌入方式嵌入方式指的是在HTML&lt;head&gt;标签中的&lt;style&gt;标签下书写 CSS 代码。示例： 1234567&lt;head&gt; &lt;style&gt; .content &#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt; 链接方式链接方式指的是使用HTML头部的&lt;head&gt;标签引入外部的CSS文件。示例： 123&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt; 导入方式导入方式指的是使用CSS规则引入外部CSS文件。示例： 123&lt;style&gt; @import url(style.css);&lt;/style&gt; 2. link和@import有什么区别 link属于HTML，通过&lt;link&gt;标签中的href属性来引入外部文件，除了加载CSS外，还可以定义RSS等其他事务;而@import属于CSS，所以导入语句应写在CSS中，要注意的是导入语句应写在样式表的开头，否则无法正确导入外部文件,且只能加载CSS。 @import是CSS2.1才出现的概念，所以如果浏览器版本较低，无法正确导入外部样式文件，link无兼容问题。 当HTML文件被加载时，link引用的文件会同时被加载，而@import引用的文件则会等页面全部下载完毕再被加载。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 3. 文件路径../main.css 、./main.css、main.css、/main.css有什么区别 相对路径../main.css：父级目录(上级路径)./main.css和main.css：当前目录/main.css：根目录 4. console.log是做什么用的 console:控制台;log:日志直译为在控制台输出日志信息，控制台即开发者工具，是浏览器的一部分，所以console.log用于开发者调试代码。 5. text-align有几个值，分别有什么作用？为什么text-align:justify没有效果？写截图说明区别 text-align left：把文本排列到左边。 right：把文本排列到右边。 center：把文本排列到中间。 inherit：从父元素继承 text-align 属性的值。 justify：实现两端对齐文本效果。 text-align:justify没有效果的原因:文本太短未占满一行,text-align:justify体现不出效果。 6. px、em、rem分别是什么？有什么区别？如何使用 css单位 名称 相同点 不同点 px 像素(Pixel) 相对单位 px的值准确稳定，相对于屏幕分辨率 em em 相对单位 相对于父级元素的字体大小(继承性)，即em的值是不固定的，它随着其父级元素的变化而变化 rem 根(root)em 相对单位 相对于html根元素的字体大小，rem的值是不固定的，它随着html根元素的变化而变化，不受父级元素的影响 7. 对chrome 审查元素的功能做个简单的截图介绍]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Form表单]]></title>
    <url>%2F2017%2F05%2F07%2FForm%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[1. form表单有什么作用？有哪些常用的input标签，分别有什么作用？ 表单的作用是搜集用户的输入，用户提交表单时向服务器传输数据，从而实现用户与web服务器的交互。 常用的input标签：12345678910111213141516171819&lt;input type=&quot;text&quot;&gt;:定义用于文本输入的单行输入字段（默认宽度为20个字符）&lt;input type=&quot;password&quot;&gt;:定义密码字段&lt;input type=&quot;radio&quot;&gt;:定义单选按钮，允许用户在有限数量的选项中选择一个&lt;input type=&quot;checkbox&quot;&gt;:定义复选框&lt;input type=&quot;submit&quot;&gt;:定义用于向表单处理程序提交表单的按钮。&lt;input type=&quot;button&quot;&gt;:定义按钮&lt;input type=&quot;number&quot;&gt;:用于应该包含数字值的输入字段&lt;input type=&quot;date&quot;&gt;:用于应该包含日期的输入字段&lt;input type=&quot;color&quot;&gt;:用于应该包含颜色的输入字段，根据浏览器支持，颜色选择器会出现输入字段中。&lt;input type=&quot;range&quot;&gt;:用于应该包含一定范围内的值的输入字段，根据浏览器支持，输入字段能够显示为滑动控件&lt;input type=&quot;month&quot;&gt;:允许用户选择月份和年份，根据浏览器的支持，日期选择器会出现在输入字段中&lt;input type=&quot;week&quot;&gt;:允许用户选择周和年,根据浏览器支持，日期选择器会出现输入字段中。&lt;input type=&quot;time&quot;&gt;:允许用户选择时间（无时区）,根据浏览器支持，时间选择器会出现输入字段中。&lt;input type=&quot;datetime&quot;&gt;:允许用户选择日期和时间（有时区）,根据浏览器支持，日期选择器会出现输入字段中。&lt;input type=&quot;datetime-local&quot;&gt;:允许用户选择日期和时间（无时区）,根据浏览器支持，日期选择器会出现输入字段中。&lt;input type=&quot;email&quot;&gt;:用于应该包含电子邮件地址的输入字段，根据浏览器支持，能够在被提交时自动对电子邮件地址进行验证。&lt;input type=&quot;search&quot;&gt;:用于搜索字段（搜索字段的表现类似常规文本字段）。&lt;input type=&quot;tel&quot;&gt;:用于应该包含电话号码的输入字段，目前只有Safari 8支持该类型&lt;input type=&quot;url&quot;&gt;:用于应该包含URL地址的输入字段，根据浏览器的支持，在提交时能够自动验证url字段。 2. post和get方式有什么区别 get适用于非敏感数据的提交，post适用于敏感数据的提交 当使用get方法时，表单数据在页面地址栏中是可见的；当使用post方法时，表单数据在页面地址栏中是不可见的。 get适用于数据的查询和获取，post适用于数据的增加删除和修改 get方法提交的数据最多只能是1024字节，理论上post没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB 3. 在input里，name有什么作用 post和get的时候，name和input中的值会形成键/值对，服务器端的表单处理程序只有通过name才能获取到相应的用户输入。 4. radio如何分组 为属于同一组（类别）的选项设置相同的name值 123456&lt;input type=&quot;radio&quot; name=&quot;city&quot; value=&quot;beijing&quot;&gt;北京&lt;input type=&quot;radio&quot; name=&quot;city&quot; value=&quot;shanghai&quot;&gt;上海&lt;input type=&quot;radio&quot; name=&quot;city&quot; value=&quot;hangzhou&quot;&gt;杭州&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女 5. placeholder属性有什么作用 placeholder属性规定用以描述输入字段预期值的提示，该提示会在用户输入值之前显示在输入字段中 placeholder 属性适用于以下输入类型：text、search、url、tel、email 以及 password 6. type=hidden隐藏域有什么作用？ 标签&lt;input type=&quot;hidden&quot; name=&quot;&quot; value=&quot;&quot;&gt;标签的作用是：隐藏不想让用户看到的信息，但是这些信息对于Web应用又是非常必要的。 暂存信息：后端在构造web页面的过程中，通过hidden隐藏域在页面中添加了相关数据信息（用户对网页进行操作时可能会用到这些数据信息） 信息安全：后端在构造web页面的过程中，可以通过hidden隐藏域在页面中添加相关的验证信息，当form表单被提交后，服务器会收到该验证信息，通过一定的算法校验该验证信息，可以有效防止非法请求对数据库的增删改查，提高了web应用的安全性。]]></content>
      <categories>
        <category>HTML入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2017%2F05%2F07%2FHTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 网页乱码的问题是如何产生的？怎样解决 产生原因 乱码通常在使用英文以外的字符才会出现 编辑器保存的编码格式和浏览器解析时的解码格式不匹配 解决方法在html中明确编码格式，即在&lt;head&gt;中添加&lt;meta charset=&quot;xxx&quot;&gt;,向浏览器明确你所以使用的编码格式 2. 颜色有几种写法， 红色、 绿色、蓝色、白色、黑色如何表示？ 透明黑色如何表示？ 第一种：使用颜色名来表示red;green;blue;white;black 第二种：采用百分比表示，相对于255来取百分比 12345red: rgb(100%,0,0)green:rgb(0,50%,0)blue: rgb(0,0,100%)white:rgb(100%,100%,100%)black:rgb(0,0,0) 第三种：使用6位16进制代码表示 12345red: rgb(#FF0000)green:rgb(#008000)blue: rgb(#0000FF)white:rgb(#FFFFFF)black:rgb(#0000FF) 第四种：使用0-255的十进制数来表示 12345red: rgb(255,0,0)green:rgb(0,128,0)blue: rgb(0,255,0)white:rgb(255,255,255)black:rgb(0,0,0) 透明黑色rgba(0,0,0,0) 3. &lt;!doctype html&gt;的作用是什么它为浏览器提供一项信息（声明），即HTML是用什么版本编写的。&lt;!doctype html&gt;作用是告诉浏览器HTML的版本是HTML5 4. 严格模式和混杂模式指什么 在严格模式(&lt;!DOCTYPE html&gt;)中，浏览器以其支持的最高标准呈现页面 在混杂模式中，页面以一种比较宽松的向后兼容的方式显示。混杂模式通常模拟老式浏览器的行为以防止老站点无法工作 5. meta 有什么作用，常见的值有哪些 meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。meta标签的作用有：搜索引擎优化（SEO），定义页面使用语言，自动刷新并指向新的页面，实现网页转换时的动态效果，控制页面缓冲，网页定级评价，控制网页显示的窗口等。 meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 常见值1.name属性name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。meta标签的name属性语法格式是：&lt;meta name=&quot;参数&quot;content=&quot;具体的参数值&quot;&gt;主要有以下几种参数：1234567Keywords(关键字)//keywords用来告诉搜索引擎你网页的关键字是什么description(网站内容描述)//description用来告诉搜索引擎你的网站主要内容robots(机器人向导)//robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引;content的参数有all,none,index,noindex,follow,nofollow。默认是all。author(作者)//标注网页的作者generator//代表说明网站的采用的什么软件制作COPYRIGHT//代表说明网站版权信息revisit-after//代表网站重访,7days代表7天 2.http-equiv属性相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。meta标签的http-equiv属性语法格式是：&lt;meta http-equiv=&quot;参数&quot;content=&quot;参数变量值&quot;&gt;主要有以下几种参数：12345678910Expires(期限)//可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输;必须使用GMT的时间格式Pragma(cache模式)//禁止浏览器从本地计算机的缓存中访问页面内容Refresh(刷新)//自动刷新并指向新页面Set-Cookie(cookie设定)//如果网页过期，那么存盘的cookie将被删除;必须使用GMT的时间格式Window-target(显示窗口的设定)//强制页面在当前窗口以独立页面显示content-Type(显示字符集的设定)//设定页面使用的字符集content-Language（显示语言的设定）Cache-Control指定请求和响应遵循的缓存机制imagetoolbar//指定是否显示图片工具栏，当为false代表不显示，当为true代表显示Content-Script-Type//W3C网页规范，指明页面中脚本的类型 6. &lt;meta http-equiv=&quot;X-UA-compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;有什么作用 如果安装Google Chrome Frame：GCF，则使用GCF渲染； 如果未安装GCF，系统安装IE8或以上版本，则使用最高版本IE渲染； 否则，这个设定可以忽略。 7. 常见的浏览器有哪些，什么内核 浏览器 内核 IE/国产浏览器 Trident Firefox Gecko Safari Webkit Chrome/国产浏览器 Chromium/Bink opera Presto]]></content>
      <categories>
        <category>HTML入门</category>
      </categories>
  </entry>
</search>