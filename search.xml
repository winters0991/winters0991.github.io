<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2F2017%2F05%2F12%2F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1. DOM0 事件和DOM2级在事件监听使用方式上有什么区别？ DOM0：把一个方法赋值给一个元素的事件处理程序属性，这样处理，事件处理程序被认为是元素的方法，事件处理程序在元素的作用域下运行，this就是当前元素。这样的缺陷是：同一个事件只能有一个事件监听函数，再次添加会产生覆盖。 1234var btnClick = document.getElementById(&apos;btnClick&apos;);btnClick.onclick = function handler() &#123; alert(this.id);&#125;; //bthClick DOM2：这种方式可以给一个同一个元素添加多个处理事件，同时它的this也指向元素本身。 1234var btnClick = document.getElementById(&apos;btnClick&apos;);btnClick.addEventListener(&apos;click&apos;, function() &#123; alert(this.id);&#125;, false); //btnClick 2. attachEvent与addEventListener的区别？ 适用浏览器不同：attachEvent是IE的事件处理方法，addEventListener是标准浏览器的处理方式。 参数个数不相同：addEventListener有三个参数，attachEvent只有两个，attachEvent添加的事件处理程序只能发生在冒泡阶段，addEventListener第三个参数可以决定添加的事件处理程序是在捕获阶段还是冒泡阶段处理。 第一个参数意义不同：addEventListener第一个参数是事件类型（比如click，load），而attachEvent第一个参数指明的是事件处理函数名称（onclick，onload）。 事件处理程序的作用域不相同：addEventListener的作用域是元素本身，this是指的触发元素，而attachEvent事件处理程序会在全局变量内运行，this是window。 为一个事件添加多个事件处理程序时，执行顺序不同：addEventListener添加会按照添加顺序执行，而attachEvent添加多个事件处理程序时顺序无规律。 3. 解释IE事件冒泡和DOM2事件传播机制？ IE的事件冒泡：事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的元素。 DOM2：DOM2级事件规定事件流包括三个阶段，事件捕获阶段，处于目标阶段，事件冒泡阶段，首先发生的是事件捕获，为截取事件提供机会，然后是实际目标接收事件，最后是冒泡阶段。 4. 如何阻止事件冒泡？ 如何阻止默认事件？ DOM浏览器： 阻止事件冒泡：stopPropagation() 阻止默认事件：preventDefault() IE浏览器： 阻止事件冒泡：cancelBubble 默认为false，设置为true后可以取消事件冒泡 阻止默认事件：returnValue 默认为true，设为false可以取消事件默认行为 5. 有如下代码，要求当点击每一个元素li时控制台展示该元素的文本内容。不考虑兼容。12345678910111213&lt;ul class=&quot;ct&quot;&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;饥人谷&lt;/li&gt; &lt;li&gt;前端6班&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var lis = document.querySelectorAll(&apos;.ct li&apos;);for(var i = 0; i &lt; lis.length; i++)&#123; lis[i].addEventListener(&apos;click&apos;, function()&#123; console.log(this.innerText); &#125;)&#125;&lt;/script&gt; 6. 补全代码，要求： 当点击按钮开头添加时在这里是元素前添加一个新元素，内容为用户输入的非空字符串；当点击结尾添加时在最后一个 li 元素后添加用户输入的非空字符串. 当点击每一个元素li时控制台展示该元素的文本内容。12345678910111213141516171819202122232425262728293031323334&lt;ul class=&quot;ct&quot;&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;饥人谷&lt;/li&gt; &lt;li&gt;任务班&lt;/li&gt;&lt;/ul&gt;&lt;input class=&quot;ipt-add-content&quot; placeholder=&quot;添加内容&quot;/&gt;&lt;button id=&quot;btn-add-start&quot;&gt;开头添加&lt;/button&gt;&lt;button id=&quot;btn-add-end&quot;&gt;结尾添加&lt;/button&gt;&lt;script&gt; var ipt = $(&apos;.ipt-add-content&apos;); var addStart = $(&apos;#btn-add-start&apos;); var endStart = $(&apos;#btn-add-end&apos;); var ct = $(&apos;.ct&apos;); ct.addEventListener(&apos;click&apos;, function(e)&#123; console.log(e.target.innerText); &#125;) addStart.addEventListener(&apos;click&apos;, function()&#123; var li = document.createElement(&apos;li&apos;); li.innerText = ipt.value; ct.insertBefore(li, ct.firstChild); &#125;) endStart.addEventListener(&apos;click&apos;, function()&#123; var li = document.createElement(&apos;li&apos;); li.innerText = ipt.value; ct.appendChild(li); &#125;) function $(id)&#123; return document.querySelector(id); &#125; function $$(clas)&#123; return document.querySelectorAll(clas); &#125;&lt;/script&gt; 7. 补全代码，要求：当鼠标放置在li元素上，会在img-preview里展示当前li元素的data-img对应的图片。12345678910111213141516171819202122&lt;ul class=&quot;ct&quot;&gt; &lt;li data-img=&quot;1.png&quot;&gt;鼠标放置查看图片1&lt;/li&gt; &lt;li data-img=&quot;2.png&quot;&gt;鼠标放置查看图片2&lt;/li&gt; &lt;li data-img=&quot;3.png&quot;&gt;鼠标放置查看图片3&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;img-preview&quot;&gt;&lt;/div&gt;&lt;script&gt;var preview = document.querySelector(&apos;.img-preview&apos;);var ct = document.querySelector(&apos;.ct&apos;);ct.addEventListener(&apos;mouseover&apos;, function(e)&#123; if(e.target.tagName.toLowerCase() === &apos;li&apos;)&#123; var img = document.createElement(&apos;img&apos;); img.src = e.target.getAttribute(&apos;data-img&apos;); preview.appendChild(img); &#125;&#125;)ct.addEventListener(&apos;mouseout&apos;, function(e)&#123; if(e.target.tagName.toLowerCase() === &apos;li&apos;)&#123; preview.innerHTML = &apos;&apos;; &#125;&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DOM操作]]></title>
    <url>%2F2017%2F05%2F12%2FDOM%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. dom对象的innerText和innerHTML有什么区别？ innerText是一个可写属性，返回元素内包含的文本内容，在多层次的时候会按照元素由浅到深的顺序拼接其内容。 innerHTML属性作用和innerText类似，但是不是返回元素的文本内容，而是返回元素的HTML结构，在写入的时候也会自动构建DOM。 2. elem.children和elem.childNodes的区别？ Element.children：子元素列表（HTMLCollection），返回一个HTMLCollection对象，包括当前元素节点的所有子元素。 Element.childNodes：子元素列表（NodeList），返回一个NodeList集合，包括当前节点的HTML元素节点，还返回Text节点和Comment节点。 3. 查询元素有几种常见的方法？ES5的元素选择方法是什么? getElementById() getElementsByClassName() getElementsByTagName() getElementsByName()ES5的元素选择方法： querySelector() querySelectorAll() 4. 如何创建一个元素？如何给元素设置属性？如何删除属性 创建元素：createElement() 给元素设置属性：setAttribute(“属性名”, “属性值”) 删除属性：romoveAttribute(“属性名”) 5. 如何给页面元素添加子元素？如何删除页面元素下的子元素? 添加元素：var newDiv = document.createELement(‘newDivName’);document.body.appendChild(newDiv); 删除元素：document.body.removeChild(newDiv); 6. element.classList有哪些方法？如何判断一个元素的 class 列表中是包含某个 class？如何添加一个class？如何删除一个class? element.classList 是一个只读属性，返回一个元素的类属性的实时 DOMTokenList集合。 add(className)：添加类 remove(className)：删除类 contains(className)：是否包含指定类名，返回布尔值 toString()：将类数组对象转为字符串 element.classList.contains(className)：判断是否包含且返回布尔值 element.classList.add(className)：添加类 element.classList.remove(className)：删除类 7. 如何选中如下代码所有的li元素？ 如何选中btn元素？12345678910&lt;div class=&quot;mod-tabs&quot;&gt; &lt;ul&gt; &lt;li&gt;list1&lt;li&gt; &lt;li&gt;list2&lt;li&gt; &lt;li&gt;list3&lt;li&gt; &lt;/ul&gt; &lt;button class=&quot;btn&quot;&gt;点我&lt;/btn&gt;&lt;/div&gt;//document.querySelectorAll(&apos;.mod-tabs &gt; ul &gt; li&apos;)document.querySelector(&apos;.btn&apos;)]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F05%2F12%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. \d，\w, \s, [a-zA-Z0-9], \b, ., *, +, ?, x{3}, ^, $ 分别是什么? \d 表示：数字字符 [0-9] \w 表示：单词字符、字母、数字、下划线 [a-zA-Z_0-9] \s 表示：空白符 [\t\n\x0B\f\r] [a-zA-Z0-9] 表示：字母（包括大小写）、数字0-9s \b 表示：单词边界 . 表示：除了回车符和换行符之外的所有字符 [^\r\n] * 表示：出现零次或多次（任意次） + 表示：出现一次或多次（至少出现一次） ? 表示：出现零次或一次（最多出现一次） x{3} 表示：x出现3次 ^ 表示：以xxx开头 $ 表示：以xxx结尾 2. 写一个函数trim(str)，去除字符串两边的空白字符123function trim(str)&#123; return str.replace(/^\s+|\s+$/g, &apos;&apos;);&#125; 3. 写一个函数isEmail(str)，判断用户输入的是不是邮箱 1234function isEmail(str)&#123; var reg = /^\w+@[\w.-]+$/; return reg.test(str);&#125; 4. 写一个函数isPhoneNum(str)，判断用户输入的是不是手机号123function isPhoneNum(str)&#123; return /^(\+86-)?1[34578]\d&#123;9&#125;$/.test(str);&#125; 5. 写一个函数isValidUsername(str)，判断用户输入的是不是合法的用户名（长度6-20个字符，只能包括字母、数字、下划线）123function isValidUsername(str)&#123; return /^\w&#123;6,20&#125;$/.test(str)&#125; 6. 写一个函数isValidPassword(str), 判断用户输入的是不是合法密码（长度6-20个字符，只包括大写字母、小写字母、数字、下划线，且至少包括两种）12345678function isValidPassword(str)&#123; if(str.length &lt; 6 || str.length &gt; 20 || /\W/.test(str))&#123; return false; &#125;else if(/(^[A-Z]+$)|(^[a-z]+$)|(^[0-9]+$)|(^_+$)/.test(str))&#123; return false; &#125; return true;&#125; 7. 写一个正则表达式，得到如下字符串里所有的颜色123var re = /#[0-9a-fA-F]&#123;6&#125;/g;var subj = &quot;color: #121212; background-color: #AA00ef; width: 12px; bad-colors: f#fddee &quot;console.log( subj.match(re) ) // [&apos;#121212&apos;, &apos;#AA00ef&apos;] 8. 下面代码输出什么? 为什么? 改写代码，让其输出[‘hunger’, ‘world’].1234var str = &apos;hello &quot;hunger&quot; , hello &quot;world&quot;&apos;;var pat = /&quot;.*&quot;/g;str.match(pat);//输出：[&quot;&quot;hunger&quot; , hello &quot;world&quot;&quot;] 为贪婪模式状态下//修改： var pat = /&quot;.*?&quot;/]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Math&数组&Date]]></title>
    <url>%2F2017%2F05%2F11%2FMath-%E6%95%B0%E7%BB%84-Date%2F</url>
    <content type="text"><![CDATA[Math1. 写一个函数，返回从min到max之间的随机整数，包括min不包括max123function randomInt(min, max) &#123; return Math.floor(Math.random() * (max - min)) + min;&#125; 非作业内容 //检测随机数出现频率1234567891011121314151617function randomInt(min,max)&#123;//得出每个随机数的次数 var MAX = 10000; var obj = &#123;&#125;; for(var i = 0; i &lt; MAX; i++)&#123; var val = Math.floor(Math.random() * (max - min)) + min; if(obj[val] === undefined)&#123; obj[val] = 1; &#125;else&#123; obj[val]++; &#125; &#125;//得出每个随机数的频率 for(var key in obj)&#123; obj[key] = obj[key]/MAX &#125;console.log(obj); 2. 写一个函数，返回从min都max之间的随机整数，包括min包括max123function randomInt(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min;&#125; 3. 写一个函数，生成一个长度为 n 的随机字符串，字符串字符的取值范围包括0到9，a到 z，A到Z。1234567891011function getRandStr(len)&#123; var dict = &apos;0123456789abcdefghijkmnlopqrstuvwxyzABCDEFGHIJKMNLOPQRSTUVWXYZ&apos;; var ch, str = &apos;&apos;; for(var i = 0; i &lt; len; i++)&#123; var idx = Math.floor(Math.random() * 62); ch = dict[idx]; str += ch; &#125; return str;&#125;var str = getRandStr(10); // 0a3iJiRZap 4. 写一个函数，生成一个随机 IP 地址，一个合法的 IP 地址为 0.0.0.0~255.255.255.255 123456789function getRandIP()&#123; var obj = []; for(var i = 0; i &lt; 4; i++)&#123; obj[i] = Math.floor(Math.random() * 256); &#125; return obj.join(&apos;.&apos;);&#125;var ip = getRandIP()console.log(ip) // 10.234.121.45 5. 写一个函数，生成一个随机颜色字符串，合法的颜色为#000000~ #ffffff12345678910111213function getRandColor()&#123; var dict = &apos;0123456789abcdef&apos;; var len = dict.length; var ch, str = &apos;&apos;; for(var i = 0; i &lt; 6; i++)&#123; var idx = Math.floor(Math.random() * len); ch = dict[idx]; str += ch; &#125; return &apos;#&apos; + str;&#125;var color = getRandColor()console.log(color) // #3e2f1b 数组1. 数组方法里push、pop、shift、unshift、join、split分别是什么作用？用 splice函数分别实现push、pop、shift、unshift方法 push() 方法添加一个或多个元素到数组的末尾，并返回数组新的长度（length 属性值）。 pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。 shift() 方法从数组中删除第一个元素，并返回该元素。此方法更改数组的长度。 unshift() 方法在数组的开头添加一个或者多个元素，并返回数组新的 length 值。 join() 方法将数组（或一个类数组对象）的所有元素连接到一个字符串中。 split（）方法通过将字符串分成子字符串，从而将一个String对象拆分为一个字符串数组。 splice() 方法通过删除现有元素和/或添加新元素来更改数组的内容。12345678910111213141516var arr = [1, 2, 3, 4, 5];//实现push()方法：arr.splice(5,0,6);console.log(arr);//[1, 2, 3, 4, 5, 6]//实现pop()方法：arr.splice(5,1);console.log(arr);//[1, 2, 3, 4, 5]//实现shift()方法：arr.splice(0,0,0);console.log(arr);//[0, 1, 2, 3, 4, 5]//实现unshift()方法：arr.splice(0,1);console.log(arr);//[1, 2, 3, 4, 5] 2. 写一个函数，操作数组，数组中的每一项变为原来的平方，在原数组上操作123456789function squareArr(arr)&#123; for(var i = 0; i &lt; arr.length; i++)&#123; arr[i] = arr[i] * arr[i]; &#125; return arr;&#125;var arr = [2, 4, 6]squareArr(arr)console.log(arr) // [4, 16, 36] 3. 写一个函数，操作数组，返回一个新数组，新数组中只包含正数，原数组不变12345678910111213function filterPositive(arr)&#123; var newArr = []; for(var i = 0; i &lt; arr.length; i++)&#123; if(typeof arr[i] === &apos;number&apos; &amp;&amp; arr[i] &gt; 0)&#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;var arr = [3, -1, 2, &apos;饥人谷&apos;, true];var newArr = filterPositive(arr);console.log(newArr) //[3, 2]console.log(arr) //[3, -1, 2, &apos;饥人谷&apos;, true] Date1. 写一个函数getChIntv，获取从当前时间到指定日期的间隔时间123456789101112function getChIntv(time)&#123; var nowTime = Date.now(); var endTime = Date.parse(time) - 8*60*60*1000; var intTime = endTime - nowTime; var days = parseInt(intTime / (1000*60*60*24)); var hours =parseInt( (intTime % (1000*60*60*24)) / (1000*60*60)); var minutes = parseInt(((intTime % (1000*60*60*24)) % (1000*60*60)) / (1000*60)); var seconds = parseInt((((intTime % (1000*60*60*24)) % (1000*60*60)) % (1000*60)) / 1000); return &apos;距除夕还有 &apos;+days+&apos; 天 &apos;+hours+&apos; 小时 &apos;+minutes+&apos; 分 &apos;+seconds+&apos; 秒&apos;;&#125;var str = getChIntv(&quot;2017-02-08&quot;);console.log(str); // 距除夕还有 4 天 12 小时 16 分 14 秒 2. 把hh-mm-dd格式数字日期改成中文日期123456789101112131415161718function getChsDate(time)&#123; var dict = &apos;零,一,二,三,四,五,六,七,八,九,十,十一,十二,十三,十四,十五,十六,十七,十八,十九,二十,二十一,二十二,二十三,二十四,二十五,二十六,二十七,二十八,二十九,三十,三十一&apos;; dict = dict.split(&apos;,&apos;); var arr = time.split(&apos;-&apos;); var year = arr[0]; var month = arr[1]; var day = arr[2]; var yearCh = []; for(var i = 0; i &lt; 4; i++)&#123; yearCh.push(dict[parseInt(year[i])]); &#125; var monthCh = dict[parseInt(month)]; var dayCh = dict[parseInt(day)]; var str = yearCh.join(&apos;&apos;)+&apos;年&apos;+monthCh+&apos;月&apos;+dayCh+&apos;日&apos;; return str;&#125;var str = getChsDate(&apos;2015-01-08&apos;);console.log(str); // 二零一五年一月八日 3. 写一个函数，参数为时间对象毫秒数的字符串格式，返回值为字符串。假设参数为时间对象毫秒数t，根据t的时间分别返回如下字符串: 刚刚（ t 距当前时间不到1分钟时间间隔） 3分钟前 (t距当前时间大于等于1分钟，小于1小时) 8小时前 (t 距离当前时间大于等于1小时，小于24小时) 3天前 (t 距离当前时间大于等于24小时，小于30天) 2个月前 (t 距离当前时间大于等于30天小于12个月) 8年前 (t 距离当前时间大于等于12个月)12345678910111213141516171819function friendlyDate(time)&#123; var nowTime = Date.now(); var intTime = ( nowTime - time ) / 1000; var result; if(intTime &lt; 60)&#123; return result = &apos;刚刚&apos;; &#125;else if(intTime &lt; 60*60)&#123; return result = parseInt(intTime / 60) +&apos;分钟前&apos;; &#125;else if(intTime &lt; 60*60*24)&#123; return result = parseInt(intTime / (60*60)) +&apos;小时前&apos;; &#125;else if(intTime &lt; 60*60*24*30)&#123; return result = parseInt(intTime / (60*60*24)) +&apos;天前&apos;; &#125;else if(intTime &lt; 60*60*24*30*12)&#123; return result = parseInt(intTime / (60*60*24*30)) +&apos;个月前&apos;; &#125; return result = parseInt(intTime / (60*60*24*30*12)) +&apos;年前&apos;;&#125;var str = friendlyDate( &apos;1484286699422&apos; ) // 1分钟前var str2 = friendlyDate(&apos;1483941245793&apos;) //4天前]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符串与JSON]]></title>
    <url>%2F2017%2F05%2F11%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8EJSON%2F</url>
    <content type="text"><![CDATA[1. 使用数组拼接出如下字符串12345678910111213141516var prod = &#123; name: &apos;女装&apos;, styles: [&apos;短款&apos;, &apos;冬季&apos;, &apos;春装&apos;]&#125;;function getTplStr(data)&#123; var arr = []; arr.push(&apos;&lt;dl class=&quot;product&quot;&gt;&apos;+&apos;\n&apos;); arr.push(&apos;\t&apos;+&apos;&lt;dt&gt;&apos;+data.name+&apos;&lt;/dt&gt;&apos;+&apos;\n&apos;); for(var key in data.styles)&#123; arr.push(&apos;\t&apos;+&apos;&lt;dd&gt;&apos;+data.styles[key]+&apos;&lt;/dd&gt;&apos;+&apos;\n&apos;) &#125; arr.push(&apos;&lt;/dl&gt;&apos;); return arr.join(&apos;&apos;);&#125;;var result = getTplStr(prod); //result为下面的字符串console.log(result); 123456&lt;dl class=&quot;product&quot;&gt; &lt;dt&gt;女装&lt;/dt&gt; &lt;dd&gt;短款&lt;/dd&gt; &lt;dd&gt;冬季&lt;/dd&gt; &lt;dd&gt;春装&lt;/dd&gt;&lt;/dl&gt; 2. 写出两种以上声明多行字符串的方法 方法一：利用转义符\ 123456var longString = &quot;hello\ ji\ ren\ gu&quot;;longString// &quot;hello ji ren gu&quot; 方法二：利用连接运算符（+） 123456var longString = &apos;hello &apos; + &apos;ji &apos; + &apos;ren &apos; + &apos;gu&apos;;longString// &quot;hello ji ren gu&quot; 3. 补全如下代码,让输出结果为字符串: hello\饥人谷12var str = &apos;hello\\\\饥人谷&apos;console.log(str) 4. 以下代码输出什么?为什么123var str = &apos;jirengu\nruoyu&apos;console.log(str.length)//输出：13 使用了\n换行，占一个字符，空格不会计算在长度内 5. 写一个函数，判断一个字符串是回文字符串，如 abcdcba是回文字符串, abcdcbb不是 12345678910function fn(str)&#123; var str1 = str.split(&apos;&apos;).reverse().join(&apos;&apos;); if(str === str1)&#123; console.log(&apos;true&apos;) &#125;else&#123; console.log(&apos;false&apos;) &#125; &#125;fn(&apos;abcdcba&apos;)//turefn(&apos;abcdcbb&apos;)//false 6. 写一个函数，统计字符串里出现频率最多的字符12345678910111213141516171819function max(str) &#123; var obj = &#123;&#125;; for (var i = 0; i &lt; str.length; i++)&#123; if(obj[str[i]])&#123; obj[str[i]]++; &#125;else&#123; obj[str[i]] = 1; &#125; &#125; var sum = 0; var maxStr; for(var key in obj)&#123; if(obj[key] &gt; sum)&#123; sum = obj[key]; maxStr = key; &#125; &#125; return maxStr+&apos;:&apos;+sum;&#125; 7. 写一个camelize函数，把my-short-string形式的字符串转化成myShortString形式的字符串，如12345678910111213camelize(&quot;background-color&quot;) == &apos;backgroundColor&apos;camelize(&quot;list-style-image&quot;) == &apos;listStyleImage&apos;function camelize(str)&#123; var arr = []; for(var i = str.length-1; i &gt;= 0; i--)&#123; if(str[i-1] == &apos;-&apos;)&#123; arr.unshift(str[i].toUpperCase()); &#125;else&#123; arr.unshift(str[i]); &#125; &#125; return arr.join(&apos;&apos;).split(&apos;-&apos;).join(&apos;&apos;);&#125; 8. 写一个 ucFirst函数，返回第一个字母为大写的字符 （*）123456789ucFirst(&quot;hunger&quot;) == &quot;Hunger&quot;function ucFirst (str)&#123; var arr = []; arr.push(str[0].toUpperCase()); for(var i = 1; i &lt; str.length; i++)&#123; arr.push(str[i]); &#125; return arr.join(&apos;&apos;);&#125; 9. 写一个函数truncate(str, maxlength), 如果str的长度大于maxlength，会把str截断到maxlength长，并加上…，如1234567891011truncate(&quot;hello, this is hunger valley,&quot;, 10) == &quot;hello, thi...&quot;;truncate(&quot;hello world&quot;, 20) == &quot;hello world&quot;function truncate(str, maxlength)&#123; var str2; if(str.length &lt;= maxlength)&#123; str2 = str; &#125;else&#123; str2 = str.substr(0,maxlength)+&apos;...&apos;; &#125; return str2;&#125; 10. 什么是 json？什么是 json 对象？什么是 json 对象字面量？什么是 JSON内置对象？ JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于JavaScript（Standard ECMA-262 3rd Edition - December 1999）的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使JSON成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成(网络传输速度)。 简单说，每个JSON对象，就是一个值。要么是简单类型的值，要么是复合类型的值，但是只能是一个值，不能是两个或更多的值。这就是说，每个JSON文档只能包含一个值。JSON对值的类型和格式有严格的规定： 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。 简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。 字符串必须使用双引号表示，不能使用单引号。 对象的键名必须放在双引号里面。 数组或对象最后一个成员的后面，不能加逗号。 空数组和空对象都是合格的JSON值，null本身也是一个合格的JSON值。 JSON对象字面量是一种简单的描述以及声明方式。 JSON是javascript中的内置对象，提供了JSON.parse()、JSON.stringify()等方法。 11. 如何把JSON 格式的字符串转换为对象？如何把对象转换为 JSON 格式的字符串?12345678var json = &#123; &quot;name&quot;: &quot;jirengu&quot;, &quot;age&quot;: 100&#125;;var json_str = JSON.stringify(json); //对象转为字符串console.log(json_str);console.log(JSON.parse(json_str)); //字符串转为对象]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[引用类型对象拷贝]]></title>
    <url>%2F2017%2F05%2F10%2F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[1. 引用类型有哪些？非引用类型有哪些 引用类型值（对象、数组、函数、正则）：指的是那些保存在堆内存中的对象，变量中保存的实际上只是一个指针，这个指针执行内存中的另一个位置，由该位置保存对象。 基本类型值（数值、布尔值、字符串、null和undefined）：指的是保存在栈内存中的简单数据段。 2. 如下代码输出什么？为什么12345var obj1 = &#123;a:1, b:2&#125;;var obj2 = &#123;a:1, b:2&#125;;console.log(obj1 == obj2); //输出：false obj1与0bj2指向不同的地址console.log(obj1 = obj2); //输出：&#123;a:1, b:2&#125; obj2赋值给obj1console.log(obj1 == obj2); //输出：ture obj1与obj2地址相同 3. 如下代码输出什么? 为什么 12345678910111213141516var a = 1var b = 2var c = &#123; name: &apos;饥人谷&apos;, age: 2 &#125;var d = [a, b, c]var aa = avar bb = bvar cc = cvar dd = da = 11b = 22c.name = &apos;hello&apos;d[2][&apos;age&apos;] = 3console.log(aa) //输出：1 基本类型 把a赋值给aaconsole.log(bb) //输出：2 同上console.log(cc) //输出：&#123;name: &quot;hello&quot;, age: 3&#125; 引用类型 地址相同 d[2][&apos;age&apos;] = 3 改变&apos;age&apos;值 console.log(dd) //输出：[1,2,&#123;name: &quot;hello&quot;, age: 3&#125;] 引用类型 地址相同 4. 如下代码输出什么? 为什么12345678910111213var a = 1var c = &#123; name: &apos;jirengu&apos;, age: 2 &#125;function f1(n)&#123; ++n&#125;function f2(obj)&#123; ++obj.age&#125;f1(a) f2(c) f1(c.age) console.log(a) //输出：1 基本类型 a的值赋给了n，++n变化n的值，a不会发生变化console.log(c) //输出：&#123;name: &apos;jirengu&apos;, age: 3&#125; 引用类型 c指向的地址赋值给了obj 5. 过滤如下数组，只保留正数，直接在原数组上操作1234567891011var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; for (var i = 0; i &lt; arr.length; i++)&#123; if (arr[i] &lt;= 0)&#123; arr.splice(i, 1); filter(arr); &#125; &#125;&#125;filter(arr)console.log(arr) // [3,1,2] 6. 过滤如下数组，只保留正数，原数组不变，生成新数组123456789101112131415var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; var newArr = []; var j = 0; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; 0 ) &#123; newArr[j] = arr[i]; j++; &#125; &#125; return newArr;&#125;var arr2 = filter(arr)console.log(arr2) // [3,1,2]console.log(arr) // [3,1,0,-1,-2,2,-5] 7. 写一个深拷贝函数，用两种方式实现12345678910111213141516171819第一种function deepCopy(oldObj)&#123; var newObj = &#123;&#125;; for(var key in oldObj)&#123; if(typeof oldObj[key] === &apos;number&apos; || typeof oldObj[key] === &apos;string&apos; || typeof oldObj[key] === &apos;boolen&apos; || oldObj[key] === null || oldObj[key] === undefined)&#123; newObj[key] = oldObj[key]; &#125; else&#123; newObj[key] = deepCopy(oldObj[key]); &#125; &#125; return newObj;&#125;第二种 function deepCopy(oldObj)&#123; var newObj = JSON.parse(JSON.stringify(oldObj)); return newObj; &#125;]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[函数与作用域]]></title>
    <url>%2F2017%2F05%2F10%2F%E5%87%BD%E6%95%B0%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[1. 函数声明和函数表达式有什么区别 函数声明必须带有标示符（Identifier）（即函数名称），而函数表达式则可以省略这个标示符。 函数声明:function functionName(){} function 函数名称 (参数：可选){ 函数体 }函数表达式：var fn = function(){}function 函数名称（可选）(参数：可选){ 函数体 } 函数声明语句中的函数名是一个变量名，变量指向函数对象。函数定义表达式和通过var声明变量一样，其函数被提前到了脚本或函数的顶部，因此它在整个脚本和或函数内都是可见的。这样的话，只有函数变量声明提前了，函数的初始化代码仍然在原来的位置。但是使用函数声明的话，函数名称和函数体均提前了，即脚本中的函数和函数中嵌套的函数都会在当前上下文中其它代码之前声明，也即可以在声明一个函数之前调用它。 2. 什么是变量的声明前置？什么是函数的声明前置 变量声明前置：JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部。12console.log(a);var a = 1; 即123var a;console.log(a);a = 1; 函数声明前置：JavaScript引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。12f();function f() &#123;&#125; 3. arguments 是什么 arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。123456789var f = function(one) &#123; console.log(arguments[0]); console.log(arguments[1]); console.log(arguments[2]);&#125;f(1, 2, 3)// 1// 2// 3 4. 函数的”重载”怎样实现 重载是很多面向对象语言实现多态的手段之一，在静态语言中确定一个函数的手段是靠方法签名——函数名+参数列表，也就是说相同名字的函数参数个数不同或者顺序不同都被认为是不同的函数，称为函数重载。 在JavaScript中没有函数重载的概念，函数通过名字确定唯一性，参数不同也被认为是相同的函数，后面的覆盖前面的，但可以在函数体针对不同的参数调用执行相应的逻辑。12345678910111213function printPeopleInfo(name, age, sex)&#123; if(name)&#123; console.log(name); &#125; if(age)&#123; console.log(age); &#125; if(sex)&#123; console.log(sex); &#125;&#125;printPeopleInfo(&apos;Byron&apos;, 26);printPeopleInfo(&apos;Byron&apos;, 26, &apos;male&apos;); 5. 立即执行函数表达式是什么？有什么作用 立即执行函数表达式（Immediately-Invoked Function Expression），简称IIFE。表示定义函数之后，立即调用该函数。 123(function()&#123; var a = 1;&#125;)() 其他写法： 123(function fn1() &#123;&#125;);[function fn2() &#123;&#125;];1, function fn3() &#123;&#125;; 作用：隔离作用域。 6. 求n!，用递归来实现123456function factor(n)&#123; if(n === 1) &#123; return 1 &#125; return n * factor(n-1)&#125; 7. 以下代码输出什么？1234567891011121314 function getInfo(name, age, sex)&#123; console.log(&apos;name:&apos;,name); console.log(&apos;age:&apos;, age); console.log(&apos;sex:&apos;, sex); console.log(arguments); arguments[0] = &apos;valley&apos;; console.log(&apos;name&apos;, name); &#125;getInfo(&apos;饥人谷&apos;, 2, &apos;男&apos;);/* 输出：name:饥人谷 age:2 sex:男 [&quot;饥人谷&quot;,2,&quot;男&quot;] name valley */getInfo(&apos;小谷&apos;, 3);/* 输出：name:小谷 age:3 sex:undefined [&quot;小谷&quot;,3] name valley */getInfo(&apos;男&apos;);/* 输出：name:男 age:undefiend sex:undefined [&quot;男&quot;] name valley */ 8. 写一个函数，返回参数的平方和？1234567891011function sumOfSquares()&#123; var result=0; for(var i=0;i&lt;arguments.length;i++)&#123; result=result+arguments[i]*arguments[i]; &#125; console.log(result);&#125;var result = sumOfSquares(2,3,4)var result2 = sumOfSquares(1,3)console.log(result) //29console.log(result) //10 9. 如下代码的输出？为什么1234console.log(a);var a = 1;console.log(b);/* 输出：undefined 报错：b is not defined 原因：变量提升，没有b变量的声明*/ 10. 如下代码的输出？为什么12345678sayName(&apos;world&apos;);//输出：hello world 函数声明前置sayAge(10);//报错：sayAge is not a function 函数表达式不前置function sayName(name)&#123; console.log(&apos;hello &apos;, name);&#125;var sayAge = function(age)&#123; console.log(age);&#125;; 11. 如下代码输出什么? 写出作用域链查找过程伪代码123456789101112131415161718192021222324252627282930313233var x = 10bar() function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo()&#125;/* 输出：101.globalContext = &#123; AO: &#123; x: 10 foo: function bar: function &#125; Scope: null&#125;foo.[[scope]] = globalContext.AObar.[[scope]] = globalContext.AO2.调用bar()barContext = &#123; AO: &#123; x: 30 &#125; Scope: bar.[[scope]] = globalContext.AO&#125;3.调用foo()fooContext = &#123; AO: &#123;&#125; Scope: foo.[[scope]] = globalContext.AO&#125; */ 12. 如下代码输出什么? 写出作用域链查找过程伪代码123456789101112131415161718192021222324252627282930313233var x = 10;bar() function bar()&#123; var x = 30; function foo()&#123; console.log(x) &#125; foo();&#125;/* 输出：301.globalContext = &#123; AO: &#123; x: 10 bar: function &#125; Scope: null&#125;bar.[[scope]] = globalContext.AO2.调用bar()barContext = &#123; AO: &#123; x: 30 foo: function &#125; Scope: bar.[[scope]] = globalContext.AO&#125;foo.[[scope]] = barContext.AO3.调用foo()fooContext = &#123; AO: &#123;&#125; Scope: foo.[[scope]] = barContext.AO&#125; */ 13. 以下代码输出什么? 写出作用域链的查找过程伪代码1234567891011121314151617181920212223242526272829303132var x = 10;bar() function bar()&#123; var x = 30; (function ()&#123; console.log(x) &#125;)()&#125;/* 输出：301.globalContext = &#123; AO: &#123; x: 10 bar: function &#125; Scope: null&#125;bar.[[scope]] = globalContext.AO2.调用bar()barContext = &#123; AO: &#123; x: 30 function()&#123;&#125; &#125; Scope: bar.[[scope]] = globalContext.AO&#125;function.[[scope]] = barContext.AO3.调用function()functionContext = &#123; AO: &#123;&#125; Scope: function.[[scope]] = barContext.AO&#125; */ 14. 以下代码输出什么？ 写出作用域链查找过程伪代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var a = 1;function fn()&#123; console.log(a) var a = 5 console.log(a) a++ var a fn3() fn2() console.log(a) function fn2()&#123; console.log(a) a = 20 &#125;&#125;function fn3()&#123; console.log(a) a = 200&#125;fn()console.log(a)/* 输出： undefined 5 6 1 20 2001.globalContext = &#123; AO: &#123; a: 1 ==&gt;a: 200 fn: function fn3: function &#125; Scope: null&#125;fn.[[scope]] = globalContext.AOfn3.[[scope]] = globalContext.AO2.调用fn()fnContext = &#123; AO: &#123; a: undefined(输出：undefined)==&gt;5(输出：5)==&gt;6 fn2: function &#125; Scope: fn.[[scope]] = globalContext.AO&#125;fn2.[[scope]] = fnContext.AO3.调用fn3()fn3Context = &#123; AO: &#123;&#125; Scope: fn3.[[scope]] = globalContext.AO&#125;输出：14.调用fn2()fn2Context = &#123; AO: &#123;&#125;输出：6 ==&gt;a: 20(输出：20) Scope: fn2.[[scope]] = fnContext.AO&#125;5.console.log(a) 输出：200 */]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据类型&运算符&流程控制语句]]></title>
    <url>%2F2017%2F05%2F10%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E8%BF%90%E7%AE%97%E7%AC%A6-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[1. JavaScript定义了几种数据类型?哪些是原始类型?哪些是复杂类型?原始类型和复杂类型的区别是什么? JavaScript的数据类型，共有六种。 数值（number）：整数和小数 字符串（string）：字符组成的文本 布尔值（boolean）：true（真）和false（假）两个特定值 undefined：表示“未定义”或不存在，即此处目前没有任何值 null：表示空缺，即此处应该有一个值，但目前为空 对象（object）：各种值组成的集合，又可以分为以下子类型： 狭义的对象（object） 数组（array） 函数（function） 正则表达式（regexp） Symbol：生成一个全局唯一的值。 原始类型（primitive type）的值：数值、字符串、布尔值，它们是最基本的数据类型，不能再细分了。 复杂类型（complex type）的值：对象，对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。 特殊值：undefined和null。 原始类型和复杂类型的区别: 基本类型变量存的是值，复杂类型的变量存的是内存地址。 基本类型在赋值的时候拷贝值，复杂类型在赋值的时候只拷贝地址，不拷贝值。 2. typeof和instanceof的作用和区别? typeof运算符可以返回一个值的数据类型，可能有以下结果: 数值、字符串、布尔值分别返回number、string、boolean。 函数返回function。 undefined返回undefined。 typeof可以用来检查一个没有声明的变量，而不报错。实际编程中，这个特点通常用在判断语句。 除此以外，其他情况都返回object。 如果我们希望获取一个对象是否是数组，或判断某个变量是否是某个对象的实例则要选择使用instanceof。instanceof通过返回一个布尔值来判断一个变量是否某个对象的实例。 3. 如何判断一个变量是否是数字、字符串、布尔、函数 使用typeof运算符1234typeof 123 === &apos;number&apos; //判断是否为数字typeof &apos;123&apos; === &apos;string&apos; //判断是否为字符串typeof false ===&apos;boolean&apos; //判断是否为布尔typeof v ===&apos;function&apos; //判断是否为函数 4. NaN是什么? 有什么特别之处? NaN：Not a Number，表示非数字，NaN和任何值都不相等，包括自己 5. 如何把非数值转化为数值? 有三个函数可以把非数值转换为数值 Number() parseInt() parseFloat Number规则相当复杂而且不合理，几乎不使用，常用的是后两个，且规则类似 忽略字符串前面的空白字符，找到第一个非空白字符 如果第一个字符不是-或者数字返回NaN 如果是继续解析，直到非数值模式为止 0开头会当做八进制，0x开头会当做十六进制，但是可以指定第二个参数指定基数 6. ==与===有什么区别 ===是严格意义的相等，只需注意NaN和NaN不等。 使用==时，javascript会进行类型转换： 如果两个值类型相同，则执行严格相等的运算 如果两个值的类型不同 如果一个是null，一个是undefined，那么相等 如果一个是数字，一个是字符串，先将字符串转为数字，然后比较 如果一个值是true/false则将其转为1/0比较 如果一个值是对象，一个是数字或字符串，则尝试使用valueOf和toString转换后比较 其它就不相等了 7. break与continue有什么区别 break 用于强制退出循环体，执行循环后面的语句 continue 用于退出本次循环，执行下次循环 8. void 0 和 undefined在使用场景上有什么区别 undefined 可以在局部作用域中被覆写 void 运算返回值始终都是 undefined 9. 以下代码的输出结果是?为什么?1234console.log(1+1); //2 两个操作数都是数字，加法运算 console.log(&quot;2&quot;+&quot;4&quot;); //&quot;24&quot; 两个参数都是字符串,字符串拼接 console.log(2+&quot;4&quot;); //&quot;24&quot; 有一个参数是字符串,会把另外一个参数转换为字符串进行拼接console.log(+&quot;4&quot;); //4 只有一个字符串，将其转换为数字 10. 以下代码的输出结果是?123var a = 1; a+++a; //输出3，a++优先级高，运算结果为1，此时a=2,所以输出3typeof a+2; //输出&quot;number2&quot;,typeof优先级高，输出字符串&quot;number&quot;,然后与数字2相加，数字转换为字符串然后拼接 11. 以下代码的输出结果是? 为什么123var a = 1;var b = 3;console.log( a+++b );//输出4，a++优先级高，运算结果为1，然后与b相加 12. 遍历数组，把数组里的打印数组每一项的平方123var arr = [3,4,5]//for(var i = 0; i &lt; arr.length; i++)&#123;console.log(arr[i]*arr[i])&#125;//输出结果：9 16 25 13. 遍历 JSON, 打印里面的值123456var obj = &#123; name: &apos;hunger&apos;, sex: &apos;male&apos;, age: 28 &#125;//for(var key in obj)&#123;console.log(obj[key])&#125; 14. 以下代码输出结果是? 为什么123456789101112131415161718var a = 1, b = 2, c = 3;var val = typeof a + b || c &gt;0console.log(val) //优先级：typeof, +, &gt;, || 依次运算输出结果为：number2var d = 5;var data = d ==5 &amp;&amp; console.log(&apos;bb&apos;) console.log(data) //输出：bb undefined console.log(&apos;bb&apos;)先执行输出bb,&amp;&amp;前为ture,则返回console.log(&apos;bb&apos;)的值，即返回undefined,所以data为undefined(&amp;&amp;（短路）=&gt;如果第一个值为true则返回第二个值；如果第一个值为false则返回第一个值)var data2 = d = 0 || console.log(&apos;haha&apos;)console.log(data2)//输出：haha undefined console.log(&apos;haha&apos;)先执行输出haha,||优先级高于=，比较0(false)和console.log(&apos;haha&apos;)，输出undefined,右结合赋值给data2,所以data2为undefined(||（短路）=&gt;如果第一个值为true则返回第一个值；如果第一个值为false则返回第二个值) var x = !!&quot;Hello&quot; + (!&quot;world&quot;, !!&quot;from here!!&quot;);console.log(x)//输出：2 !&quot;world&quot;为false, !!&quot;from here!!&quot;为ture, !!&quot;Hello&quot;为ture, 所以为ture+ture, 输出为2]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS相关概念]]></title>
    <url>%2F2017%2F05%2F09%2FJS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[1. CSS和JS在网页中的放置顺序是怎样的？ 一般将css放置head里用style包裹，也可以使用link标签引入。 js使用script标签引入且一般放置在body闭合标签之前。 2. 解释白屏和FOUC1.白屏 如果把样式放在底部，对于IE浏览器，chrome等（CSS全部加载后再呈现,有可能等待时间长），在某些场景下(新窗口打开，刷新等)页面会出现白屏，而不是内容逐步展现。 使用@import标签，即使CSS放入link, 并且放在头部,也可能出现白屏。 对于图片和CSS, 在加载时会并发加载(如一个域名下同时加载两个文件)。 但在加载JavaScript时，会禁用并发，并且阻止其他内容的下载。所以把JavaScript放入页面顶部也会导致白屏现象。 2.FOUC Flash of Unstyled Content “无样式内容闪烁“：有些浏览器是边渲染边呈现，CSS放置body标签底部，会出现加载html结束后才一次性加载css样式，从而导致页面闪烁。 3. async和defer的作用是什么？有什么区别 &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 &lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 &lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 从实用角度来讲，首先把所有脚本都放置到 &lt;/body&gt; 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。 由图得知： defer 和 async 在网络读取（下载）这部分是一样的，都是异步的（相较于 HTML 解析）。 两者的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的。 关于 defer，由图知它是按照加载顺序执行脚本的，这一点要善加利用。 async 则是乱序执行，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行。 async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics。 4. 简述网页的渲染机制 解析 HTML 标签, 构建 DOM 树 解析 CSS 标签, 构建 CSSOM 树 把 DOM 和 CSSOM 组合成 渲染树 (render tree) 在渲染树的基础上进行布局, 计算每个节点的几何结构 把每个节点绘制到屏幕上 (painting)]]></content>
      <categories>
        <category>JavaScript入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS规范&垂直居中]]></title>
    <url>%2F2017%2F05%2F09%2FCSS%E8%A7%84%E8%8C%83-%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[1. 说一说你平时写代码遵守的编码规范 关于命名 语义化标签优先 命名体现功能，不涉及表现样式(颜色、字体、边框、背景等) 所有命名都使用英文小写 命名用引号包裹 用中横线连接 关于html与css 嵌套元素应当缩进一次（即两个空格） 减少标签的数量 为选择器分组时，将单独的选择器单独放在一行。 css的 :后加个空格， {前加个空格 每条声明后都加上分号 换行，而不是放到一行 颜色用小写，用缩写, #fff 小数不用写前缀, 0.5s -&gt; .5s；0不用加单位 尽量缩写， margin: 5px 10px 5px 10px -&gt; margin: 5px 10px 遵守编码规范bootstrap 2. 垂直居中有几种实现方式，给出代码范例 height=line-height实现单行文本垂直居中： demo 利用padding值相等实现：demo 绝对定位 利用负margin demo 利用transform demo 利用margin: auto demo vertical-align: middle demo dispaly: table-cell demo]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容]]></title>
    <url>%2F2017%2F05%2F09%2FCSS%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[1. 什么是 CSS hack 由于不同厂商的浏览器或某浏览器的不同版本（如IE6-IE11/Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器或不同版本写相应的CSS code的过程，叫做CSS hack。 CSS hack大致有3种表现形式，CSS属性前缀法、选择器前缀法以及IE条件注释法（即HTML头部引用if IE）hack，实际项目中CSS hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。 2. 谈一谈浏览器兼容的思路 要不要做？ 产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先） 成本的角度 (有无必要做) 做到什么程度？ 让哪些浏览器支持哪些效果 如何做？ 明确效果是要优雅降级还是渐进增强：1.渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。2.优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 根据兼容需求选择技术框架/库(jquery) 根据兼容需求选择兼容工具(html5shiv.js、respond.js、css reset、normalize.css、Modernizr) postCSS 条件注释、CSS Hack、js 能力检测做一些修补 3. 列举5种以上浏览器兼容的写法 inline-block不兼容IE6、7，兼容写法： 12345div &#123; display: inline-block; *zoom: 1; *display: inline;&#125; IE6、7清除浮动： 12345678.clearfix:after&#123; content: &apos;&apos;; display: block; clear: both;&#125;.clearfix&#123; *zoom: 1;&#125; 浮动元素双倍margin： 123456.content &#123; float: left; width: 200px; margin-left: 10px; display: inline;&#125; 设置元素的最小高度(min-height)： 12345.ct &#123; min-height: 500px; height: auto !important; height: 500px;&#125; 禁用IE默认的垂直滚动条： 123html &#123; overflow: auto;&#125; 4. 以下工具/名词是做什么的？ 条件注释用于HTML源码中被IE有条件解释的语句。条件注释可被用来向IE提供及隐藏代码。使用了条件注释的页面在IE9中可正常工作，但在IE10中无法正常工作。 IE10不再支持条件注释。 IE Hack针对IE浏览器的不同版本去写不同的CSS，让它能在这些浏览器中得到我们想要的页面效果。常用方法：CSS属性前缀法、选择器前缀法以及IE条件注释法。 js 能力检测使用js检测浏览器支持的属性，以便展示效果。目标不是识别特定的浏览器，而是识别浏览器的能力。 html5shiv.js通过使用html5shiv.js让IE9以下版本浏览器支持所有的HTML5标签。 respond.jsrespond.js让不支持css3 Media Query的浏览器包括IE6-IE8支持查询。 css resetcss reset(css重置、清除css样式)重置样式，清除浏览器默认样式。 normalize.cssnormalize.css 是一个可以定制的CSS文件，它让不同的浏览器在渲染网页元素的时候形式更统一。 ModernizrModernizr是一个开源的JS库，它使得那些基于访客浏览器的不同（指对新标准支持性的差异）而开发不同级别体验的设计师的工作变得更为简单。它使得设计师可以在支持HTML5和CSS3的浏览器中充分利用HTML5和CSS3的特性进行开发，同时又不会牺牲其他不支持这些新技术的浏览器的控制。 postCSSPostCSS可以直观的理解为：它就是一个平台；PostCSS提供了一个解析器，它能够将CSS解析成抽象语法树（AST）；通过在PostCSS这个平台上，能够开发一些插件，来处理CSS，比如热门的：autoprefixer；能够使用JavaScript来开发插件。]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浮动定位&BFC&边距合并]]></title>
    <url>%2F2017%2F05%2F09%2F%E6%B5%AE%E5%8A%A8%E5%AE%9A%E4%BD%8D-BFC-%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[1. 浮动元素有什么特征？对父容器、其他浮动元素、普通元素、文字分别有什么影响? 浮动元素会脱离正常的文档流，使其浮动到父元素的行的一端(元素向左或向右移动，直到碰到浮动元素，或者达到父元素内容的边界，不包括padding)，并且其他元素将忽略该浮动元素并填补其原先的空间。 对父容器的影响：元素浮动后，会脱离正常文档流，在原文档中，该浮动元素似乎消失了，因此它不能撑开父元素，容易造成父元素的塌陷。 对其他浮动元素的影响：若是同一方向浮动：兄弟元素相对该浮动元素按照从左到右(float:left)或者从右到左(float:right)的顺序依次排列。若是反方向浮动：兄弟元素和浮动元素将组成两个向左或向右的浮动队列，分别相对浮动方向同时向行中间浮动。他们尽可能处于同一行，如果行的宽度不足以容纳这两个队列，两个队列将错开成两行。 对普通元素的影响：若是块级元素：该块级元素会忽视浮动元素而占据它的位置，并且该块级元素会处于浮动元素的下层(并且无法通过z-index属性改变他们的层叠关系)，然而它的内容文字和其他行内元素将会环绕浮动元素。若是内联元素：内联元素将环绕浮动元素排列。 对文字的影响：文字将环绕浮动元素排列。 2. 清除浮动指什么? 如何清除浮动? 两种以上方法 清理浮动指解决float所导致的父元素塌陷问题。 清除浮动方法： 设置clear属性 父元素形成BFC，设置的方法有： float: left/right overflow: hidden/auto/scroll display: table-cell/table-caption/inline-block position: absolute/fixed 相对较好的方法：设置伪元素 方法一： 12345678.clearfix&#123; *zoom:1; &#125;.clearfix:after&#123; content:&quot;&quot;; display:block; clear:both; &#125; 方法二： 12345678.clearfix&#123; *zoom:1; &#125;.clearfix:after&#123; content:&quot;&quot;; display:table; clear:both; &#125; 3. 有几种定位方式，分别是如何实现定位的，参考点是什么，使用场景是什么？ position: absolute relative fixed sticky inherit static 1.position: relative 相对定位 不脱离文档流的布局，只改变自身的位置，在文档流原来的位置遗留空白区域。定位的起始位置为此元素原来在文档流中的位置。 使用场景：微调元素位置。 2.position: absolute 绝对定位 脱离文档流的布局，遗留下来的空间由后面的元素填充。定位的起始位置为最近的父元素(postion不为static)，否则为Body文档本身。 使用场景：常在页面布局中使用。 3.position: fixed 固定定位 脱离文档流的布局，空间由后面的元素填充。相对于浏览器窗口进行定位，不随着滚动条的移动而改变位置。 使用场景：登录框覆盖层、广告、回到顶部标签等。 4. z-index 有什么作用? 如何使用? z-index属性适用于定位元素（position属性值为relative 或absolute或fixed的对象），用来确定定位元素在垂直于显示屏方向（称为Z轴）上的层叠顺序，也就是说如果元素是没有定位的，对其设置的z-index会是无效的。 拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 5. position:relative和负margin都可以使元素位置发生偏移?二者有什么区别 positon:relative元素偏移后不脱离文档流，保留空间，不会影响其他元素； 负margin元素偏移后移动原来的空间，影响文档流中其他元素的位置。 6. BFC 是什么？如何生成 BFC？BFC 有什么作用？举例说明 BFC(Block Format Content):块级格式化上下文，它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 布局规则1.内部的Box会在垂直方向，一个接一个地放置。2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。3.每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。4.BFC的区域不会与float box重叠。5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。6.计算BFC的高度时，浮动元素也参与计算。 如何生成BFC：父元素设置： float: left/right overflow: hidden/auto/scroll display: table-cell/table-caption/inline-block position: absolute/fixed 作用：1.BFC的区域不会与float box重叠。我们可以通过通过触发main生成BFC，来实现自适应两栏布局。demo2.清除内部浮动demo3.防止垂直 margin 重叠demo 7. 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例 外边距合并指的是：当两个垂直外边距相遇时，它们将合并形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距高度中的较大者。1.当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。2.当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上/或下外边距也会发生合并。（父子）3.假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并。4.外边距合并时递归的，如果这个外边距遇到另一个元素的外边距，它还会发生合并。 如何避免：1.为父元素设置BFC或padding或border2.兄弟元素间设置float或display:inline-block或positon:absulutedemo]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS常见样式2]]></title>
    <url>%2F2017%2F05%2F09%2FCSS%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F2%2F</url>
    <content type="text"><![CDATA[1. 盒模型包括哪些属性 content(内容) padding(内边距) border(边框) margin(外边距) 2. text-align: center的作用是什么，作用在什么元素上？能让什么元素水平居中 作用于块级元素，可以使块级元素中的inline、inline-block及文本水平居中 3. IE盒模型和W3C盒模型有什么区别? IE盒模型(怪异模式)：width=content+padding+border W3C标准盒模型：width=content IE678版本在不添加doctype时为怪异模式，添加doctype变成标准模式 使用box-sizing:border-box进行盒模型模式切换 4. 以下代码的作用？兼容性？123*&#123; box-sizing: border-box;&#125; 盒模型切换为怪异模式，即width=content+padding+border 兼容性 5. inline-block有什么特性？如何去除缝隙？高度不一样的inline-block元素如何顶端对齐? 内联块：将对象呈递为内联元素，但是对象的内容作为块级元素呈递。旁边的内联元素会被呈递在同一行内，允许空格。即同时具有内联元素和块级元素的特性。 去除缝隙的方法：1.移除标签段之间的空格2.使用margin负值1234.space a &#123; display: inline-block; margin-right: -3px;&#125; 3.删除闭合标签4.使用font-size:0123456.space &#123; font-size: 0;&#125;.space a &#123; font-size: 12px;&#125; 5.使用letter-spacing123456.space &#123; letter-spacing: -3px;&#125;.space a &#123; letter-spacing: 0;&#125; 6.使用word-spacing123456.space &#123; word-spacing: -6px;&#125;.space a &#123; word-spacing: 0;&#125; 顶端对齐：vertical-align:top; 6. CSS sprite 是什么? CSS sprite 即精灵图，雪碧图。是一种网页图片应用处理方式。它可以将一个页面涉及到的所有零星图片都包含到一张大图中去，这样一来，当访问该页面时，载入的图片就不会像以前那样一幅一幅地慢慢显示出来了。 优点 利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能。 CSS Sprites能减少图片的字节。 解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率。 更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变，维护起来更加方便。 缺点 在图片合并的时候，需要把多张图片有序的合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景；若是在宽屏，高分辨率的屏幕下的自适应页面，图片如果不够宽，很容易出现背景断裂。 CSS Sprites在开发的时候比较麻烦。 CSS Sprites在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片。]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS常见样式]]></title>
    <url>%2F2017%2F05%2F08%2FCSS%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. 块级元素和行内元素分别有哪些？动手测试并列出4条以上的特性区别 块级元素：h1,p,div,table,ul,li,ol,hr,form,dd,dt,tr,td,th 行内元素：img,span,em,strong,a,br,input,lable,select,textarea,code 特性区别： 块级元素会独占一行，默认情况下，其宽度自动填满其父元素宽度；行内元素不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下，才会换行，其宽度随元素的内容而变化 块级元素可以包含块级元素和行内元素，行内只能包含文本和行内元素 块级元素可以设置width，height属性，行内元素设置width，height属性无效 块级元素可以设置margin和padding属性，行内元素的margin和padding属性，水平方向产生效果，但竖直方向不会产生效果 块级元素对应于display:block；行内元素对应于display:inline 2. 什么是 CSS 继承? 哪些属性能继承，哪些不能？ css继承指设置上级(父级)的CSS样式，上级（父级）及以下的子级（下级）都具有此属性 不可继承的：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、page-break-before和unicode-bidi。 所有元素可继承：visibility和cursor。 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。 块状元素可继承：text-indent和text-align。 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承：border-collapse。 3. 如何让块级元素水平居中？如何让行内元素水平居中? 块级元素： (需设置固定宽度)对子元素设置margin: 0 auto (不确定宽度)将元素放置在table中，再将table的margin-left和margin-right设置成auto，将table居中,使在其之中的块级元素也居中 将块级元素转换为行内元素(通过设置display:inline)后再居中 把父元素增加float:left，同时设置position:relative和left:50%。而子元素设置position:absolute和left:-50%来实现水平居中 行内元素：在父元素中设置text-align: center 4. 单行文本溢出加 …如何实现? 核心代码123white-space: nowrap;overflow: hidden;text-overflow: ellipsis; 5. px, em, rem 有什么区别 css单位 名称 相同点 不同点 px 像素(Pixel) 相对单位 px的值准确稳定，相对于屏幕分辨率 em em 相对单位 相对于父级元素的字体大小(继承性)，即em的值是不固定的，它随着其父级元素的变化而变化 rem 根(root)em 相对单位 相对于html根元素的字体大小，rem的值是不固定的，它随着html根元素的变化而变化，不受父级元素的影响]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2F2017%2F05%2F08%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. class 和 id 的使用场景? class: 标签的类名，具有普遍性，不唯一，可重复使用，所以尽量在结构内部使用，通常用于样式定义 id: 指定标签的唯一标识，具有唯一性，所以尽量在结构外围使用，通常用于页面布局 id的样式优先级高于class 2. CSS选择器常见的有几种? 基本选择器 通配选择器 * 元素选择器 Element ID选择器 #id 类选择器 .class 组合选择器 多元素选择器 E,F 后代选择器 E F 子选择器 E&gt;F 相邻兄弟选择器 E+F 通用兄弟选择器 E~F 伪类选择器 动态伪类选择器E:link,E:visited,E:active,E:hover,E:focus 目标伪类选择器E:target 语言伪类选择器E:lang(language) 状态伪类选择器E:checked,E:enabled,E:disabled 结构伪类选择器E:first-child,E:last-child,E:root,E:nth-child(n),E:nth-last-child(n),E:nth-of-type(n),E:nth-last-of-type(n),E:first-of-type,E:last-of-type,E:only-child,E:only-of-type,E:empty 伪元素 ::first-letter,::first-line,::before,::after,::selection 属性选择器 E[attr],E[attr=val],E[attr|=val],E[attr~=val],E[attr*=val],E[attr^=val],E[attr$=val] 3. 选择器的优先级是怎样的?对于复杂场景如何计算优先级？ 优先级从高到低 !important 1,0,0,0,0 style内联样式 1,0,0,0 id选择器 0,1,0,0 类选择器 0,0,1,0 伪类选择器 0,0,1,0 属性选择器 0,0,1,0 标签选择器、伪元素 0,0,0,1 通配符选择器 0,0,0,0 浏览器自定义 对于复杂场景计算优先级：选择器的权值加到一起，大的优先；如果权值相同，后定义的优先 。 4. a:link, a:hover, a:active, a:visited 的顺序是怎样的？ 为什么？ 正确的顺序：a:link、a:visited、a:hover、a:active 原因：浏览器解释CSS时遵循“就近原则” 记忆技巧：”爱恨原则”：LoVe/HAte (LVHA) 5. 以下选择器分别是什么意思?#header{} 选择id为header的元素.header{} 选择class为header的元素.header .logo{} 选择class为header的元素中class为logo的元素.header.mobile{} 选择class同时为header和mobile的元素.header p, .header h3{} 选择class为header元素中的p和h3元素#header .nav&gt;li{} 选择id为header的元素中class为nav的直接子元素li#header a:hover{} 选择id为header的元素中a链接的hover状态#header .logo~p{} 选择id为header的元素中与class为logo的元素同级的p元素#header input[type=&quot;text&quot;]{} 选择id为header的元素中type=”text”的input标签 6. 列出你知道的伪类选择器E:link 匹配所有未被点击的链接E:visited 匹配所有已被点击的链接E:active 匹配鼠标已经按下、还没有释放的E元素E:hover 匹配鼠标悬停其上的E元素E:focus 匹配获得当前焦点的E元素E:enabled 匹配表单中可用的元素E:disabled 匹配表单中禁用的元素E:checked 匹配表单中被选中的radio或checkbox元素E::selection 匹配用户当前选中的元素E:nth-child(n) 匹配其父元素的第n个子元素，第一个编号为1E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为1E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)E:empty 匹配一个不包含任何子元素的元素，文本节点也被看作子元素 7. div:first-child和div:first-of-type的作用和区别 :first-child 匹配的是其父元素的第一个子元素，即结构上的第一个子元素。 :first-of-type 匹配的是其父元素下相同类型子元素中的第一个，这里不再限制是第一个子元素，只要是该类型元素的第一个就可以。]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[line-height & a 标签]]></title>
    <url>%2F2017%2F05%2F08%2Fline-height-a%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[1. line-height有什么作用?line-height: 2和line-height: 200%有什么区别? 设置行高 实现单行文本的垂直居中 line-height详细用法 取值为数字时：行高=子元素字体大小*数字 取值为百分比时：行高=父元素字体大小*百分比 2. 如何去查CSS属性的兼容性？比如inline-block哪些浏览器支持？ 查询兼容性网址Can I Use 3. 关于a标签 href, title, target是什么？ href：Hypertext Reference，即超文本引用，用于指定超链接目标的URL 值 描述 URL 超链接的URL。可能的值：绝对URL:指向另一个站点（比如 href=&quot;http://www.example.com/index.html&quot;）相对URL:指向站点内的某个文件（href=&quot;index.html&quot;）锚 URL:指向页面中的锚（href=&quot;#top&quot;） title:标题，成为链接的默认名称。把鼠标悬停链接上面时，会显示title的内容，以达到补充说明或者提示的效果。 属性 值 描述 dir rtl/ltr 规定元素中内容的文本方向 lang language_code 规定元素中内容的语言代码 xml:lang language_code 规定 XHTML 文档中元素内容的语言代码 target:规定在何处打开链接文档 值 描述 _blank 在新窗口中打开被链接文档 _self 默认。在相同的框架中打开被链接文档 _parent 在父框架集中打开被链接文档 _top 在整个窗口中打开被链接文档 framename 在指定的框架中打开被链接文档 2.title和alt有什么区别？ 使用alt属性是为了给那些不能看到文档中图像的浏览者提供文字说明，是图像无法显示时的替代文本，所以alt是替代图像作用而不是提供额外说明文字的。 title属性是对元素的注释说明和额外补充，当鼠标放到文字或是图片上时有title文字显示。 3.如何新窗口打开链接？&lt;a href=&quot;http://www.example.com/&quot; target=&quot;_blank&quot;&gt;EXAMPLE&lt;/a&gt; 4. display: none , visibility: hidden, opacity:0 有什么作用？有什么区别？ 方法 作用描述 事件响应 display: none 使元素隐藏；元素空间被占用；导致浏览器重绘及重排 不会触发点击事件 visibility(能见度): hidden 使元素隐藏；元素空间不被占用；导致浏览器重绘不重排 不会触发点击事件 opacity(不透明度):0 使元素透明度为0，表现为隐藏；元素空间不被占用；不导致浏览器重绘及重绘 触发点击事件 background-color:rgba(0,0,0,0) 背景色透明 触发点击事件 5. 如何去除 a 链接的默认样式？直接在 a 链接父容器添加颜色，能否继承到当前 a 链接上？ 去除a链接的默认样式：a{text-decoration: none;} 不能继承到当前a链接上，需要为其单独设置]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS基础]]></title>
    <url>%2F2017%2F05%2F07%2FCSS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 样式有几种引入方式? 内联方式内联方式指的是直接在HTML标签中的style属性中添加CSS。示例：&lt;div style=&quot;background: red&quot;&gt;&lt;/div&gt; 嵌入方式嵌入方式指的是在HTML&lt;head&gt;标签中的&lt;style&gt;标签下书写 CSS 代码。示例： 1234567&lt;head&gt; &lt;style&gt; .content &#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt; 链接方式链接方式指的是使用HTML头部的&lt;head&gt;标签引入外部的CSS文件。示例： 123&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt; 导入方式导入方式指的是使用CSS规则引入外部CSS文件。示例： 123&lt;style&gt; @import url(style.css);&lt;/style&gt; 2. link和@import有什么区别 link属于HTML，通过&lt;link&gt;标签中的href属性来引入外部文件，除了加载CSS外，还可以定义RSS等其他事务;而@import属于CSS，所以导入语句应写在CSS中，要注意的是导入语句应写在样式表的开头，否则无法正确导入外部文件,且只能加载CSS。 @import是CSS2.1才出现的概念，所以如果浏览器版本较低，无法正确导入外部样式文件，link无兼容问题。 当HTML文件被加载时，link引用的文件会同时被加载，而@import引用的文件则会等页面全部下载完毕再被加载。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 3. 文件路径../main.css 、./main.css、main.css、/main.css有什么区别 相对路径../main.css：父级目录(上级路径)./main.css和main.css：当前目录/main.css：根目录 4. console.log是做什么用的 console:控制台;log:日志直译为在控制台输出日志信息，控制台即开发者工具，是浏览器的一部分，所以console.log用于开发者调试代码。 5. text-align有几个值，分别有什么作用？为什么text-align:justify没有效果？写截图说明区别 text-align left：把文本排列到左边。 right：把文本排列到右边。 center：把文本排列到中间。 inherit：从父元素继承 text-align 属性的值。 justify：实现两端对齐文本效果。 text-align:justify没有效果的原因:文本太短未占满一行,text-align:justify体现不出效果。 6. px、em、rem分别是什么？有什么区别？如何使用 css单位 名称 相同点 不同点 px 像素(Pixel) 相对单位 px的值准确稳定，相对于屏幕分辨率 em em 相对单位 相对于父级元素的字体大小(继承性)，即em的值是不固定的，它随着其父级元素的变化而变化 rem 根(root)em 相对单位 相对于html根元素的字体大小，rem的值是不固定的，它随着html根元素的变化而变化，不受父级元素的影响 7. 对chrome 审查元素的功能做个简单的截图介绍]]></content>
      <categories>
        <category>CSS入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Form表单]]></title>
    <url>%2F2017%2F05%2F07%2FForm%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[1. form表单有什么作用？有哪些常用的input标签，分别有什么作用？ 表单的作用是搜集用户的输入，用户提交表单时向服务器传输数据，从而实现用户与web服务器的交互。 常用的input标签：12345678910111213141516171819&lt;input type=&quot;text&quot;&gt;:定义用于文本输入的单行输入字段（默认宽度为20个字符）&lt;input type=&quot;password&quot;&gt;:定义密码字段&lt;input type=&quot;radio&quot;&gt;:定义单选按钮，允许用户在有限数量的选项中选择一个&lt;input type=&quot;checkbox&quot;&gt;:定义复选框&lt;input type=&quot;submit&quot;&gt;:定义用于向表单处理程序提交表单的按钮。&lt;input type=&quot;button&quot;&gt;:定义按钮&lt;input type=&quot;number&quot;&gt;:用于应该包含数字值的输入字段&lt;input type=&quot;date&quot;&gt;:用于应该包含日期的输入字段&lt;input type=&quot;color&quot;&gt;:用于应该包含颜色的输入字段，根据浏览器支持，颜色选择器会出现输入字段中。&lt;input type=&quot;range&quot;&gt;:用于应该包含一定范围内的值的输入字段，根据浏览器支持，输入字段能够显示为滑动控件&lt;input type=&quot;month&quot;&gt;:允许用户选择月份和年份，根据浏览器的支持，日期选择器会出现在输入字段中&lt;input type=&quot;week&quot;&gt;:允许用户选择周和年,根据浏览器支持，日期选择器会出现输入字段中。&lt;input type=&quot;time&quot;&gt;:允许用户选择时间（无时区）,根据浏览器支持，时间选择器会出现输入字段中。&lt;input type=&quot;datetime&quot;&gt;:允许用户选择日期和时间（有时区）,根据浏览器支持，日期选择器会出现输入字段中。&lt;input type=&quot;datetime-local&quot;&gt;:允许用户选择日期和时间（无时区）,根据浏览器支持，日期选择器会出现输入字段中。&lt;input type=&quot;email&quot;&gt;:用于应该包含电子邮件地址的输入字段，根据浏览器支持，能够在被提交时自动对电子邮件地址进行验证。&lt;input type=&quot;search&quot;&gt;:用于搜索字段（搜索字段的表现类似常规文本字段）。&lt;input type=&quot;tel&quot;&gt;:用于应该包含电话号码的输入字段，目前只有Safari 8支持该类型&lt;input type=&quot;url&quot;&gt;:用于应该包含URL地址的输入字段，根据浏览器的支持，在提交时能够自动验证url字段。 2. post和get方式有什么区别 get适用于非敏感数据的提交，post适用于敏感数据的提交 当使用get方法时，表单数据在页面地址栏中是可见的；当使用post方法时，表单数据在页面地址栏中是不可见的。 get适用于数据的查询和获取，post适用于数据的增加删除和修改 get方法提交的数据最多只能是1024字节，理论上post没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB 3. 在input里，name有什么作用 post和get的时候，name和input中的值会形成键/值对，服务器端的表单处理程序只有通过name才能获取到相应的用户输入。 4. radio如何分组 为属于同一组（类别）的选项设置相同的name值 123456&lt;input type=&quot;radio&quot; name=&quot;city&quot; value=&quot;beijing&quot;&gt;北京&lt;input type=&quot;radio&quot; name=&quot;city&quot; value=&quot;shanghai&quot;&gt;上海&lt;input type=&quot;radio&quot; name=&quot;city&quot; value=&quot;hangzhou&quot;&gt;杭州&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;女 5. placeholder属性有什么作用 placeholder属性规定用以描述输入字段预期值的提示，该提示会在用户输入值之前显示在输入字段中 placeholder 属性适用于以下输入类型：text、search、url、tel、email 以及 password 6. type=hidden隐藏域有什么作用？ 标签&lt;input type=&quot;hidden&quot; name=&quot;&quot; value=&quot;&quot;&gt;标签的作用是：隐藏不想让用户看到的信息，但是这些信息对于Web应用又是非常必要的。 暂存信息：后端在构造web页面的过程中，通过hidden隐藏域在页面中添加了相关数据信息（用户对网页进行操作时可能会用到这些数据信息） 信息安全：后端在构造web页面的过程中，可以通过hidden隐藏域在页面中添加相关的验证信息，当form表单被提交后，服务器会收到该验证信息，通过一定的算法校验该验证信息，可以有效防止非法请求对数据库的增删改查，提高了web应用的安全性。]]></content>
      <categories>
        <category>HTML入门</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2017%2F05%2F07%2FHTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 网页乱码的问题是如何产生的？怎样解决 产生原因 乱码通常在使用英文以外的字符才会出现 编辑器保存的编码格式和浏览器解析时的解码格式不匹配 解决方法在html中明确编码格式，即在&lt;head&gt;中添加&lt;meta charset=&quot;xxx&quot;&gt;,向浏览器明确你所以使用的编码格式 2. 颜色有几种写法， 红色、 绿色、蓝色、白色、黑色如何表示？ 透明黑色如何表示？ 第一种：使用颜色名来表示red;green;blue;white;black 第二种：采用百分比表示，相对于255来取百分比 12345red: rgb(100%,0,0)green:rgb(0,50%,0)blue: rgb(0,0,100%)white:rgb(100%,100%,100%)black:rgb(0,0,0) 第三种：使用6位16进制代码表示 12345red: rgb(#FF0000)green:rgb(#008000)blue: rgb(#0000FF)white:rgb(#FFFFFF)black:rgb(#0000FF) 第四种：使用0-255的十进制数来表示 12345red: rgb(255,0,0)green:rgb(0,128,0)blue: rgb(0,255,0)white:rgb(255,255,255)black:rgb(0,0,0) 透明黑色rgba(0,0,0,0) 3. &lt;!doctype html&gt;的作用是什么它为浏览器提供一项信息（声明），即HTML是用什么版本编写的。&lt;!doctype html&gt;作用是告诉浏览器HTML的版本是HTML5 4. 严格模式和混杂模式指什么 在严格模式(&lt;!DOCTYPE html&gt;)中，浏览器以其支持的最高标准呈现页面 在混杂模式中，页面以一种比较宽松的向后兼容的方式显示。混杂模式通常模拟老式浏览器的行为以防止老站点无法工作 5. meta 有什么作用，常见的值有哪些 meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。meta标签的作用有：搜索引擎优化（SEO），定义页面使用语言，自动刷新并指向新的页面，实现网页转换时的动态效果，控制页面缓冲，网页定级评价，控制网页显示的窗口等。 meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 常见值1.name属性name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。meta标签的name属性语法格式是：&lt;meta name=&quot;参数&quot;content=&quot;具体的参数值&quot;&gt;主要有以下几种参数：1234567Keywords(关键字)//keywords用来告诉搜索引擎你网页的关键字是什么description(网站内容描述)//description用来告诉搜索引擎你的网站主要内容robots(机器人向导)//robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引;content的参数有all,none,index,noindex,follow,nofollow。默认是all。author(作者)//标注网页的作者generator//代表说明网站的采用的什么软件制作COPYRIGHT//代表说明网站版权信息revisit-after//代表网站重访,7days代表7天 2.http-equiv属性相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。meta标签的http-equiv属性语法格式是：&lt;meta http-equiv=&quot;参数&quot;content=&quot;参数变量值&quot;&gt;主要有以下几种参数：12345678910Expires(期限)//可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输;必须使用GMT的时间格式Pragma(cache模式)//禁止浏览器从本地计算机的缓存中访问页面内容Refresh(刷新)//自动刷新并指向新页面Set-Cookie(cookie设定)//如果网页过期，那么存盘的cookie将被删除;必须使用GMT的时间格式Window-target(显示窗口的设定)//强制页面在当前窗口以独立页面显示content-Type(显示字符集的设定)//设定页面使用的字符集content-Language（显示语言的设定）Cache-Control指定请求和响应遵循的缓存机制imagetoolbar//指定是否显示图片工具栏，当为false代表不显示，当为true代表显示Content-Script-Type//W3C网页规范，指明页面中脚本的类型 6. &lt;meta http-equiv=&quot;X-UA-compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;有什么作用 如果安装Google Chrome Frame：GCF，则使用GCF渲染； 如果未安装GCF，系统安装IE8或以上版本，则使用最高版本IE渲染； 否则，这个设定可以忽略。 7. 常见的浏览器有哪些，什么内核 浏览器 内核 IE/国产浏览器 Trident Firefox Gecko Safari Webkit Chrome/国产浏览器 Chromium/Bink opera Presto]]></content>
      <categories>
        <category>HTML入门</category>
      </categories>
  </entry>
</search>